<!DOCTYPE html>
<html lang="zh">

<head>
  <meta charset="UTF-8">
  <title>ÂÖÉÁ¥†Êï∞ÂÄºÁªÑÂêàÂàÜÊûêÂô® (Ëá™ÂÆö‰πâÁõÆÊ†áÁâà)</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
      line-height: 1.6;
    }

    .container {
      max-width: 800px;
      margin: 0 auto;
      background: rgba(255, 255, 255, 0.95);
      padding: 40px;
      border-radius: 20px;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
      backdrop-filter: blur(10px);
      position: relative;
      overflow: hidden;
    }

    .container::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(255, 255, 255, 0.1);
      pointer-events: none;
    }

    h2 {
      text-align: center;
      color: #333;
      font-size: 2.5rem;
      margin-bottom: 20px;
      font-weight: 300;
      position: relative;
      z-index: 1;
    }

    p {
      text-align: center;
      color: #666;
      margin-bottom: 25px;
      font-size: 1.1rem;
      opacity: 0.9;
      position: relative;
      z-index: 1;
    }

    .settings-container {
      text-align: center;
      margin-bottom: 30px;
      padding: 25px;
      background: rgba(255, 255, 255, 0.8);
      border-radius: 15px;
      border: 2px solid rgba(102, 126, 234, 0.1);
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
      position: relative;
      z-index: 1;
    }

    .settings-container label {
      font-weight: 600;
      font-size: 1.2em;
      margin-right: 15px;
      color: #333;
      display: inline-block;
      margin-bottom: 10px;
    }

    .settings-container input {
      width: 100px;
      padding: 12px 15px;
      border: 2px solid #e0e6ed;
      border-radius: 10px;
      font-size: 1.1em;
      text-align: center;
      transition: all 0.3s ease;
      background: white;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
    }

    .settings-container input:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
      transform: scale(1.02);
    }

    hr {
      border: none;
      border-top: 2px solid rgba(102, 126, 234, 0.1);
      margin: 30px 0;
      border-radius: 2px;
    }

    #input-container {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
      position: relative;
      z-index: 1;
    }

    .input-group {
      display: flex;
      flex-direction: column;
      padding: 20px;
      background: rgba(255, 255, 255, 0.9);
      border-radius: 15px;
      border: 2px solid rgba(102, 126, 234, 0.1);
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }

    .input-group::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(102, 126, 234, 0.1), transparent);
      transition: left 0.5s;
    }

    .input-group:hover {
      transform: translateY(-3px);
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
      border-color: #667eea;
    }

    .input-group:hover::before {
      left: 100%;
    }

    .input-group label {
      font-weight: 600;
      margin-bottom: 10px;
      color: #333;
      font-size: 1.1em;
      position: relative;
      z-index: 1;
    }

    .input-group input {
      padding: 12px 15px;
      border: 2px solid #e0e6ed;
      border-radius: 10px;
      font-size: 1em;
      text-align: center;
      margin-bottom: 10px;
      transition: all 0.3s ease;
      background: white;
      position: relative;
      z-index: 1;
    }

    .input-group input:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
      transform: scale(1.02);
    }

    .input-group input:last-child {
      margin-bottom: 0;
    }

    .input-group .max-input {
      background: linear-gradient(135deg, #fff3cd 0%, #fff8e1 100%);
      border-color: #ffc107;
    }

    .input-group .max-input:focus {
      border-color: #ff9800;
      box-shadow: 0 0 0 3px rgba(255, 152, 0, 0.1);
    }

    .input-group .max-label {
      font-size: 0.9em;
      color: #666;
      font-weight: 500;
      margin-top: 5px;
      position: relative;
      z-index: 1;
    }

    button {
      display: block;
      width: 100%;
      padding: 15px 20px;
      font-size: 1.2em;
      font-weight: 600;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      border-radius: 15px;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
      position: relative;
      z-index: 1;
      margin-bottom: 20px;
    }

    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 25px rgba(102, 126, 234, 0.4);
    }

    button:active {
      transform: translateY(0);
      box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
    }

    #result-list {
      margin-top: 30px;
      padding: 0;
      list-style-type: none;
      max-height: 500px;
      overflow-y: auto;
      border: none;
      border-radius: 15px;
      padding: 20px;
      background: rgba(255, 255, 255, 0.9);
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
      backdrop-filter: blur(5px);
      position: relative;
      z-index: 1;
    }

    #result-list::-webkit-scrollbar {
      width: 8px;
    }

    #result-list::-webkit-scrollbar-track {
      background: rgba(0, 0, 0, 0.1);
      border-radius: 4px;
    }

    #result-list::-webkit-scrollbar-thumb {
      background: linear-gradient(135deg, #667eea, #764ba2);
      border-radius: 4px;
    }

    #result-list::-webkit-scrollbar-thumb:hover {
      background: linear-gradient(135deg, #5a6fd8, #6c42a0);
    }

    #result-list li {
      padding: 15px 20px;
      border-bottom: 1px solid rgba(0, 0, 0, 0.05);
      border-radius: 10px;
      margin-bottom: 10px;
      transition: all 0.3s ease;
      position: relative;
      background: rgba(255, 255, 255, 0.5);
    }

    #result-list li:last-child {
      border-bottom: none;
      margin-bottom: 0;
    }

    #result-list li:hover {
      transform: translateX(5px);
      background: rgba(255, 255, 255, 0.8);
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
    }

    .success {
      color: #28a745;
      background: linear-gradient(135deg, rgba(40, 167, 69, 0.1), rgba(40, 167, 69, 0.05));
      border-left: 4px solid #28a745;
    }

    .failure {
      color: #dc3545;
      background: linear-gradient(135deg, rgba(220, 53, 69, 0.1), rgba(220, 53, 69, 0.05));
      border-left: 4px solid #dc3545;
    }

    .analysis-section {
      margin-top: 30px;
      padding: 25px;
      background: rgba(255, 255, 255, 0.9);
      border-radius: 15px;
      border: 2px solid rgba(102, 126, 234, 0.1);
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
      backdrop-filter: blur(5px);
      position: relative;
      z-index: 1;
    }

    .analysis-section h3 {
      margin-top: 0;
      color: #333;
      font-size: 1.4em;
      font-weight: 600;
      margin-bottom: 20px;
      padding-bottom: 10px;
      border-bottom: 2px solid rgba(102, 126, 234, 0.1);
    }

    .analysis-section h4 {
      color: #495057;
      font-size: 1.2em;
      font-weight: 600;
      margin: 20px 0 15px 0;
    }

    .frequency-table {
      width: 100%;
      border-collapse: collapse;
      margin: 15px 0;
      background: white;
      border-radius: 10px;
      overflow: hidden;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
    }

    .frequency-table th,
    .frequency-table td {
      padding: 12px 15px;
      text-align: left;
      border-bottom: 1px solid rgba(0, 0, 0, 0.05);
    }

    .frequency-table th {
      background: linear-gradient(135deg, #667eea, #764ba2);
      color: white;
      font-weight: 600;
      font-size: 0.95em;
    }

    .frequency-table tbody tr:hover {
      background: rgba(102, 126, 234, 0.05);
      transform: scale(1.01);
      transition: all 0.3s ease;
    }

    .optimization-suggestion {
      margin-top: 20px;
      padding: 20px;
      background: linear-gradient(135deg, rgba(209, 236, 241, 0.8), rgba(209, 236, 241, 0.6));
      border: 2px solid rgba(190, 229, 235, 0.8);
      border-radius: 15px;
      color: #0c5460;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
      position: relative;
      overflow: hidden;
    }

    .optimization-suggestion::before {
      content: 'üí°';
      position: absolute;
      top: 15px;
      right: 20px;
      font-size: 1.5em;
      opacity: 0.3;
    }

    .optimization-suggestion strong {
      color: #004085;
      font-weight: 600;
    }

    /* ÂìçÂ∫îÂºèËÆæËÆ° */
    @media (max-width: 768px) {
      .container {
        padding: 25px 20px;
        margin: 10px;
      }

      h2 {
        font-size: 2rem;
      }

      #input-container {
        grid-template-columns: 1fr;
        gap: 15px;
      }

      .input-group {
        padding: 15px;
      }

      .settings-container {
        padding: 20px 15px;
      }

      .frequency-table th,
      .frequency-table td {
        padding: 8px 10px;
        font-size: 0.9em;
      }
    }

    /* Âä®ÁîªÊïàÊûú */
    .animate-fade-in {
      animation: fadeIn 0.6s ease-out forwards;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(20px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .animate-slide-in {
      animation: slideIn 0.5s ease-out forwards;
    }

    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateX(-20px);
      }

      to {
        opacity: 1;
        transform: translateX(0);
      }
    }

    /* Âä†ËΩΩÂä®Áîª */
    .loading {
      position: relative;
    }

    .loading::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 20px;
      height: 20px;
      margin: -10px 0 0 -10px;
      border: 2px solid #667eea;
      border-top: 2px solid transparent;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }
  </style>
</head>

<body>

  <div class="container animate-fade-in">
    <h2>üé≠ ÂÖÉÁ¥†Êï∞ÂÄºÁªÑÂêàÂàÜÊûêÂô®</h2>

    <div class="settings-container">
      <label for="target-sum-input">üéØ ËÆæÁΩÆÁõÆÊ†áÂíåÂÄº:</label>
      <input type="number" id="target-sum-input" value="28" oninput="saveToCache()">
    </div>

    <hr>

    <p>ËØ∑‰∏∫ <strong>üíßÊ∞¥, üî•ÁÅ´, ‚ö°Èõ∑, üå™Ô∏èÈ£é, üóøÂ≤©, üåøËçâ, ‚ùÑÔ∏èÂÜ∞</strong> ‰∏É‰∏™ÂÖÉÁ¥†ÂàÜÂà´ËæìÂÖ•ÂΩìÂâçÂÄºÂíåÊúÄÂ§ßÂÄºÔºàÂèØÈÄâÔºâÔºö</p>
    <div id="input-container">
    </div>

    <button onclick="generateReport()">üìä ÁîüÊàêËØ¶ÁªÜÊä•Âëä</button>

    <div style="text-align: center; margin: 20px 0;">
      <a href="index.html" style="
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 10px 20px;
        background: rgba(255, 255, 255, 0.8);
        border: 2px solid rgba(102, 126, 234, 0.3);
        border-radius: 25px;
        text-decoration: none;
        color: #667eea;
        font-weight: 600;
        transition: all 0.3s ease;
        backdrop-filter: blur(5px);
      " onmouseover="this.style.background='rgba(102, 126, 234, 0.1)'; this.style.transform='translateY(-2px)'"
        onmouseout="this.style.background='rgba(255, 255, 255, 0.8)'; this.style.transform='translateY(0)'">
        üè† ËøîÂõûÈ¶ñÈ°µ
      </a>
    </div>

    <ul id="result-list"></ul>

    <div id="analysis-container"></div>
  </div>

  <script>
    const identifiers = ['üíßÊ∞¥', 'üî•ÁÅ´', '‚ö°Èõ∑', 'üå™Ô∏èÈ£é', 'üóøÂ≤©', 'üåøËçâ', '‚ùÑÔ∏èÂÜ∞'];
    const elementNames = ['Ê∞¥', 'ÁÅ´', 'Èõ∑', 'È£é', 'Â≤©', 'Ëçâ', 'ÂÜ∞'];
    const defaultValues = [0, 0, 0, 0, 0, 0, 0];
    const inputContainer = document.getElementById('input-container');

    // È°µÈù¢Âä†ËΩΩÂä®Áîª
    document.addEventListener('DOMContentLoaded', function () {
      // ‰∏∫ËæìÂÖ•ÁªÑÊ∑ªÂä†Âª∂ËøüÂä®Áîª
      setTimeout(() => {
        const inputGroups = document.querySelectorAll('.input-group');
        inputGroups.forEach((group, index) => {
          group.style.animationDelay = `${index * 0.1}s`;
          group.classList.add('animate-fade-in');
        });
      }, 300);
    });

    // Êú¨Âú∞ÁºìÂ≠òÁõ∏ÂÖ≥ÂáΩÊï∞
    function saveToCache() {
      const data = {
        targetSum: document.getElementById('target-sum-input').value,
        elements: {},
        maxElements: {}
      };

      identifiers.forEach((name, index) => {
        const input = document.getElementById(`element-${index}`);
        const maxInput = document.getElementById(`element-max-${index}`);
        data.elements[elementNames[index]] = input.value;
        data.maxElements[elementNames[index]] = maxInput.value;
      });

      localStorage.setItem('elementAnalyzerData', JSON.stringify(data));
    }

    function loadFromCache() {
      const cached = localStorage.getItem('elementAnalyzerData');
      if (cached) {
        try {
          const data = JSON.parse(cached);

          // ÊÅ¢Â§çÁõÆÊ†áÂíåÂÄº
          if (data.targetSum) {
            document.getElementById('target-sum-input').value = data.targetSum;
          }

          // ÊÅ¢Â§çÂÖÉÁ¥†ÂÄº
          identifiers.forEach((name, index) => {
            const input = document.getElementById(`element-${index}`);
            const maxInput = document.getElementById(`element-max-${index}`);

            if (data.elements && data.elements[elementNames[index]]) {
              input.value = data.elements[elementNames[index]];
            }

            if (data.maxElements && data.maxElements[elementNames[index]]) {
              maxInput.value = data.maxElements[elementNames[index]];
            }
          });
        } catch (e) {
          console.log('ÁºìÂ≠òÊï∞ÊçÆÊ†ºÂºèÈîôËØØÔºå‰ΩøÁî®ÈªòËÆ§ÂÄº');
        }
      }
    }

    // Âä®ÊÄÅÁîüÊàê‰∏É‰∏™ÂÖÉÁ¥†ÁöÑËæìÂÖ•Ê°Ü
    identifiers.forEach((name, index) => {
      const group = document.createElement('div');
      group.className = 'input-group';

      const label = document.createElement('label');
      label.htmlFor = `element-${index}`;
      label.textContent = `${name}:`;

      const input = document.createElement('input');
      input.type = 'number';
      input.id = `element-${index}`;
      input.className = 'element-input';
      input.value = defaultValues[index];
      input.placeholder = 'ÂΩìÂâçÂÄº';
      // Ê∑ªÂä†ËæìÂÖ•‰∫ã‰ª∂ÁõëÂê¨Âô®
      input.addEventListener('input', saveToCache);

      const maxLabel = document.createElement('label');
      maxLabel.className = 'max-label';
      maxLabel.htmlFor = `element-max-${index}`;
      maxLabel.textContent = 'ÊúÄÂ§ßÂÄºÔºàÂèØÈÄâÔºâ:';

      const maxInput = document.createElement('input');
      maxInput.type = 'number';
      maxInput.id = `element-max-${index}`;
      maxInput.className = 'element-max-input max-input';
      maxInput.placeholder = '‰∏çÈôêÂà∂';
      // Ê∑ªÂä†ËæìÂÖ•‰∫ã‰ª∂ÁõëÂê¨Âô®
      maxInput.addEventListener('input', saveToCache);

      group.appendChild(label);
      group.appendChild(input);
      group.appendChild(maxLabel);
      group.appendChild(maxInput);
      inputContainer.appendChild(group);
    });

    // È°µÈù¢Âä†ËΩΩÊó∂ÊÅ¢Â§çÁºìÂ≠òÊï∞ÊçÆ
    window.addEventListener('DOMContentLoaded', loadFromCache);

    function generateReport() {
      // Ê∑ªÂä†Âä†ËΩΩÂä®Áîª
      const button = document.querySelector('button');
      const originalText = button.textContent;
      button.textContent = 'ÁîüÊàê‰∏≠...';
      button.classList.add('loading');
      button.disabled = true;

      // ‰ΩøÁî®setTimeoutËÆ©Âä®ÁîªÊúâÊó∂Èó¥ÊòæÁ§∫
      setTimeout(() => {
        try {
          performAnalysis();
        } finally {
          // ÁßªÈô§Âä†ËΩΩÁä∂ÊÄÅ
          button.textContent = originalText;
          button.classList.remove('loading');
          button.disabled = false;
        }
      }, 100);
    }

    function performAnalysis() {
      // 1. ËØªÂèñËá™ÂÆö‰πâÁöÑÁõÆÊ†áÂíåÂÄº
      const targetInput = document.getElementById('target-sum-input');
      const target = parseInt(targetInput.value, 10);

      const resultList = document.getElementById('result-list');
      resultList.innerHTML = ''; // Ê∏ÖÁ©∫‰∏äÊ¨°ÁªìÊûú

      const analysisContainer = document.getElementById('analysis-container');
      analysisContainer.innerHTML = ''; // Ê∏ÖÁ©∫‰∏äÊ¨°ÂàÜÊûêÁªìÊûú

      // 2. È™åËØÅÁõÆÊ†áÂíåÂÄºÊòØÂê¶ÊúâÊïà
      if (isNaN(target)) {
        const li = document.createElement('li');
        li.className = 'failure';
        li.textContent = 'ËæìÂÖ•Êó†ÊïàÔºåËØ∑Á°Æ‰øù"ÁõÆÊ†áÂíåÂÄº"ÊòØ‰∏Ä‰∏™ÊúâÊïàÁöÑÊï∞Â≠ó„ÄÇ';
        resultList.appendChild(li);
        return;
      }

      // 3. ËØªÂèñ‰∏É‰∏™ÂÖÉÁ¥†ÁöÑÊï∞ÂÄºÂíåÊúÄÂ§ßÂÄº
      const inputElements = document.querySelectorAll('.element-input');
      const maxInputElements = document.querySelectorAll('.element-max-input');
      const numbers = Array.from(inputElements).map(input => parseInt(input.value, 10));
      const maxValues = Array.from(maxInputElements).map(input => {
        const val = parseInt(input.value, 10);
        return isNaN(val) ? null : val;
      });

      // 4. È™åËØÅÂÖÉÁ¥†Êï∞ÂÄºÊòØÂê¶ÊúâÊïà
      if (numbers.some(isNaN)) {
        const li = document.createElement('li');
        li.className = 'failure';
        li.textContent = 'ËæìÂÖ•Êó†ÊïàÔºåËØ∑Á°Æ‰øùÊâÄÊúâÂÖÉÁ¥†ÁöÑËæìÂÖ•Ê°ÜÈÉΩÂ°´ÂÜô‰∫ÜÊúâÊïàÁöÑÊï∞Â≠ó„ÄÇ';
        resultList.appendChild(li);
        return;
      }

      // È™åËØÅÊúÄÂ§ßÂÄºÊòØÂê¶Â§ß‰∫éÁ≠â‰∫éÂΩìÂâçÂÄº
      for (let i = 0; i < numbers.length; i++) {
        if (maxValues[i] !== null && maxValues[i] < numbers[i]) {
          const li = document.createElement('li');
          li.className = 'failure';
          li.textContent = `ËæìÂÖ•Êó†ÊïàÔºö${identifiers[i]}ÁöÑÊúÄÂ§ßÂÄº(${maxValues[i]})‰∏çËÉΩÂ∞è‰∫éÂΩìÂâçÂÄº(${numbers[i]})„ÄÇ`;
          resultList.appendChild(li);
          return;
        }
      }

      const elements = numbers.map((value, index) => ({
        name: elementNames[index],
        displayName: identifiers[index],
        value: value,
        maxValue: maxValues[index]
      }));

      const failedCombinations = [];
      const elementFailureCount = {};
      const elementTotalCount = {};

      // ÂàùÂßãÂåñÂÖÉÁ¥†Â§±Ë¥•ËÆ°Êï∞ÂíåÊÄªÂá∫Áé∞Ê¨°Êï∞
      elementNames.forEach(name => {
        elementFailureCount[name] = 0;
        elementTotalCount[name] = 0;
      });

      // Êî∂ÈõÜÊâÄÊúâÁªÑÂêà
      const allCombinations = [];

      // 5. ÈÅçÂéÜÊâÄÊúâÁªÑÂêà
      for (let i = 0; i < elements.length - 2; i++) {
        for (let j = i + 1; j < elements.length - 1; j++) {
          for (let k = j + 1; k < elements.length; k++) {
            const elem1 = elements[i];
            const elem2 = elements[j];
            const elem3 = elements[k];

            allCombinations.push({
              elements: [elem1, elem2, elem3],
              sum: elem1.value + elem2.value + elem3.value
            });
          }
        }
      }

      // Âà§Êñ≠ÁªÑÂêàÊòØÂê¶ÂåÖÂê´ÁâπÂÆöÂÖÉÁ¥†ÂØπ
      function hasSpecialPair(combo) {
        const names = combo.elements.map(e => e.name);
        return (names.includes('È£é') && names.includes('Â≤©')) ||
          (names.includes('È£é') && names.includes('Ëçâ')) ||
          (names.includes('Â≤©') && names.includes('Ëçâ'));
      }

      // ÂàÜÁ¶ªÊôÆÈÄöÁªÑÂêàÂíåÁâπÊÆäÁªÑÂêà
      const normalCombinations = [];
      const specialCombinations = [];

      allCombinations.forEach(combo => {
        if (hasSpecialPair(combo)) {
          specialCombinations.push(combo);
        } else {
          normalCombinations.push(combo);
        }
      });

      // Áî®‰∫éÁ¨¨‰∏Ä‰ªΩÊä•ÂëäÔºà‰∏çÂåÖÂê´ÁâπÊÆäÁªÑÂêàÔºâÁöÑÁªüËÆ°
      const failedCombinationsNormal = [];
      const elementFailureCountNormal = {};
      const elementTotalCountNormal = {};
      elementNames.forEach(name => {
        elementFailureCountNormal[name] = 0;
        elementTotalCountNormal[name] = 0;
      });

      // ÁîüÊàêÊä•Âëä
      let combinationsCount = 0;

      // ÂÖàÊòæÁ§∫ÊôÆÈÄöÁªÑÂêà
      normalCombinations.forEach(combo => {
        combinationsCount++;
        const elem1 = combo.elements[0];
        const elem2 = combo.elements[1];
        const elem3 = combo.elements[2];
        const sum = combo.sum;

        // ÁªüËÆ°ÂÖÉÁ¥†ÊÄªÂá∫Áé∞Ê¨°Êï∞Ôºà‰∏§‰ªΩÁªüËÆ°Ôºâ
        elementTotalCount[elem1.name]++;
        elementTotalCount[elem2.name]++;
        elementTotalCount[elem3.name]++;
        elementTotalCountNormal[elem1.name]++;
        elementTotalCountNormal[elem2.name]++;
        elementTotalCountNormal[elem3.name]++;

        const li = document.createElement('li');
        let text = `${combinationsCount}. ${elem1.displayName}(${elem1.value}) + ${elem2.displayName}(${elem2.value}) + ${elem3.displayName}(${elem3.value}) = <strong>${sum}</strong>. `;

        // ‰ΩøÁî®Âä®ÊÄÅËØªÂèñÁöÑ target ÂÄºËøõË°åÂà§Êñ≠
        if (sum >= target) {
          li.className = 'success';
          text += `‚úÖ ËÉΩ`;
        } else {
          const deficit = target - sum;
          li.className = 'failure';
          text += `‚ùå ‰∏çËÉΩ (ÈúÄË¶ÅÂä† ${deficit})`;

          // ËÆ∞ÂΩïÂ§±Ë¥•ÁöÑÁªÑÂêàÔºà‰∏§‰ªΩÁªüËÆ°Ôºâ
          failedCombinations.push({
            elements: [elem1, elem2, elem3],
            sum: sum,
            deficit: deficit
          });
          failedCombinationsNormal.push({
            elements: [elem1, elem2, elem3],
            sum: sum,
            deficit: deficit
          });

          // ÁªüËÆ°Â§±Ë¥•ÁªÑÂêà‰∏≠ÂêÑÂÖÉÁ¥†Âá∫Áé∞Ê¨°Êï∞Ôºà‰∏§‰ªΩÁªüËÆ°Ôºâ
          elementFailureCount[elem1.name]++;
          elementFailureCount[elem2.name]++;
          elementFailureCount[elem3.name]++;
          elementFailureCountNormal[elem1.name]++;
          elementFailureCountNormal[elem2.name]++;
          elementFailureCountNormal[elem3.name]++;
        }

        li.innerHTML = text;
        li.classList.add('animate-slide-in');
        li.style.animationDelay = `${(combinationsCount - 1) * 0.05}s`;
        resultList.appendChild(li);
      });

      // Ê∑ªÂä†ÂàÜÁïåÁ∫ø
      if (specialCombinations.length > 0) {
        const divider = document.createElement('li');
        divider.style.borderTop = '3px solid #dc3545';
        divider.style.borderBottom = '3px solid #dc3545';
        divider.style.padding = '12px 5px';
        divider.style.margin = '10px 0';
        divider.style.backgroundColor = '#fff3cd';
        divider.style.fontWeight = 'bold';
        divider.style.textAlign = 'center';
        divider.innerHTML = '‚ö†Ô∏è ‰ª•‰∏ãÊòØÂåÖÂê´È£éÂ≤©„ÄÅÈ£éËçâ„ÄÅÂ≤©ËçâÁöÑÁâπÊÆäÁªÑÂêà ‚ö†Ô∏è';
        resultList.appendChild(divider);
      }

      // ÊòæÁ§∫ÁâπÊÆäÁªÑÂêà
      specialCombinations.forEach(combo => {
        combinationsCount++;
        const elem1 = combo.elements[0];
        const elem2 = combo.elements[1];
        const elem3 = combo.elements[2];
        const sum = combo.sum;

        // ÁªüËÆ°ÂÖÉÁ¥†ÊÄªÂá∫Áé∞Ê¨°Êï∞ÔºàÂè™ËÆ∞ÂΩïÂà∞ÊÄªÁªüËÆ°Ôºâ
        elementTotalCount[elem1.name]++;
        elementTotalCount[elem2.name]++;
        elementTotalCount[elem3.name]++;

        const li = document.createElement('li');
        let text = `${combinationsCount}. ${elem1.displayName}(${elem1.value}) + ${elem2.displayName}(${elem2.value}) + ${elem3.displayName}(${elem3.value}) = <strong>${sum}</strong>. `;

        // ‰ΩøÁî®Âä®ÊÄÅËØªÂèñÁöÑ target ÂÄºËøõË°åÂà§Êñ≠
        if (sum >= target) {
          li.className = 'success';
          text += `‚úÖ ËÉΩ`;
        } else {
          const deficit = target - sum;
          li.className = 'failure';
          text += `‚ùå ‰∏çËÉΩ (ÈúÄË¶ÅÂä† ${deficit})`;

          // ËÆ∞ÂΩïÂ§±Ë¥•ÁöÑÁªÑÂêàÔºàÂè™ËÆ∞ÂΩïÂà∞ÊÄªÁªüËÆ°Ôºâ
          failedCombinations.push({
            elements: [elem1, elem2, elem3],
            sum: sum,
            deficit: deficit
          });

          // ÁªüËÆ°Â§±Ë¥•ÁªÑÂêà‰∏≠ÂêÑÂÖÉÁ¥†Âá∫Áé∞Ê¨°Êï∞ÔºàÂè™ËÆ∞ÂΩïÂà∞ÊÄªÁªüËÆ°Ôºâ
          elementFailureCount[elem1.name]++;
          elementFailureCount[elem2.name]++;
          elementFailureCount[elem3.name]++;
        }

        li.innerHTML = text;
        li.classList.add('animate-slide-in');
        li.style.animationDelay = `${(combinationsCount - 1) * 0.05}s`;
        resultList.appendChild(li);
      });

      // ÁîüÊàê‰∏§‰ªΩÂàÜÊûêÊä•Âëä
      if (failedCombinationsNormal.length > 0) {
        // Á¨¨‰∏Ä‰ªΩÔºö‰∏çÂåÖÂê´ÁâπÊÆäÁªÑÂêàÁöÑÂàÜÊûê
        generateAnalysis(elements, failedCombinationsNormal, elementFailureCountNormal, elementTotalCountNormal, target, 'Ôºà‰∏çÂê´È£éÂ≤©„ÄÅÈ£éËçâ„ÄÅÂ≤©ËçâÁªÑÂêàÔºâ');
      }

      if (failedCombinations.length > 0 && specialCombinations.length > 0) {
        // Á¨¨‰∫å‰ªΩÔºöÂåÖÂê´ÊâÄÊúâÁªÑÂêàÁöÑÂàÜÊûê
        generateAnalysis(elements, failedCombinations, elementFailureCount, elementTotalCount, target, 'ÔºàÂåÖÂê´ÊâÄÊúâÁªÑÂêàÔºâ');
      }
    }

    function generateAnalysis(elements, failedCombinations, elementFailureCount, elementTotalCount, target, reportType = '') {
      const analysisContainer = document.getElementById('analysis-container');

      // ÂàõÂª∫ÂàÜÊûêÂå∫Âüü
      const analysisSection = document.createElement('div');
      analysisSection.className = 'analysis-section';

      // Ê∑ªÂä†Ê†áÈ¢ò
      const title = document.createElement('h3');
      title.textContent = `üìä Â§±Ë¥•ÁªÑÂêàÂàÜÊûêÊä•Âëä ${reportType}`;
      analysisSection.appendChild(title);

      // 1. ÂÖÉÁ¥†Â§±Ë¥•ÊØî‰æãÁªüËÆ°
      const freqTitle = document.createElement('h4');
      freqTitle.textContent = '1. ÂÖÉÁ¥†Â§±Ë¥•ÊØî‰æãÂàÜÊûêÔºö';
      analysisSection.appendChild(freqTitle);

      // ÂàõÂª∫È¢ëÁéáË°®Ê†º
      const table = document.createElement('table');
      table.className = 'frequency-table';

      const thead = document.createElement('thead');
      thead.innerHTML = '<tr><th>ÂÖÉÁ¥†</th><th>ÂΩìÂâçÂÄº</th><th>ÊÄªÂá∫Áé∞Ê¨°Êï∞</th><th>Â§±Ë¥•Ê¨°Êï∞</th><th>Â§±Ë¥•ÊØî‰æã</th><th>Â§±Ë¥•ÊØî‰æãÊéíÂêç</th></tr>';
      table.appendChild(thead);

      const tbody = document.createElement('tbody');

      // ËÆ°ÁÆóÂ§±Ë¥•ÊØî‰æãÂπ∂ÊåâÂ§±Ë¥•ÊØî‰æãÊéíÂ∫è
      const elementStats = Object.entries(elementFailureCount)
        .map(entry => {
          const name = entry[0];
          const failureCount = entry[1];
          const totalCount = elementTotalCount[name];
          const failureRatio = totalCount > 0 ? (failureCount / totalCount) : 0;
          return {
            name: name,
            failureCount: failureCount,
            totalCount: totalCount,
            failureRatio: failureRatio,
            value: elements.find(e => e.name === name).value
          };
        })
        .sort((a, b) => b.failureRatio - a.failureRatio)
        .map((elem, index) => ({
          ...elem,
          rank: index + 1
        }));

      const sortedElements = elementStats;

      sortedElements.forEach(elem => {
        const row = document.createElement('tr');
        if (elem.rank === 1) {
          row.style.backgroundColor = '#fff3cd';
        }
        const percentageStr = (elem.failureRatio * 100).toFixed(1);
        row.innerHTML = `
          <td><strong>${elem.name}</strong></td>
          <td>${elem.value}</td>
          <td>${elem.totalCount}</td>
          <td>${elem.failureCount}</td>
          <td>${percentageStr}%</td>
          <td>${elem.rank === 1 ? 'ü•á Á¨¨‰∏Ä' : elem.rank === 2 ? 'ü•à Á¨¨‰∫å' : elem.rank === 3 ? 'ü•â Á¨¨‰∏â' : `Á¨¨${elem.rank}`}</td>
        `;
        tbody.appendChild(row);
      });

      table.appendChild(tbody);
      analysisSection.appendChild(table);

      // 2. ÊúÄ‰ºòÂåñÂª∫ËÆÆ
      const optTitle = document.createElement('h4');
      optTitle.textContent = '2. ÊÄß‰ª∑ÊØîÊúÄ‰ºòÊñπÊ°àÔºö';
      analysisSection.appendChild(optTitle);

      // ‰ΩøÁî®ÊîπËøõÁöÑÊúÄÂ∞èÂ¢ûÂä†ÂÄº‰ºòÂåñÁÆóÊ≥ï
      function findOptimalSolution() {
        // Â§çÂà∂ÂΩìÂâçÂÖÉÁ¥†ÂÄºÂíåÊúÄÂ§ßÂÄºÈôêÂà∂
        const currentValues = {};
        const maxLimits = {};
        elements.forEach(e => {
          currentValues[e.name] = e.value;
          maxLimits[e.name] = e.maxValue;
        });

        // Ëé∑ÂèñÊúÄÂ§ßÂèØËÉΩÁöÑÂ¢ûÂä†ÂÄºËåÉÂõ¥ÔºàÁî®‰∫éÊûö‰∏æÊêúÁ¥¢Ôºâ
        const maxReasonableIncrement = Math.max(...failedCombinations.map(c => c.deficit));

        // Ê£ÄÊü•ÁªôÂÆöÂ¢ûÂä†ÂÄºÁªÑÂêà‰∏ãÁöÑÂ§±Ë¥•ÁªÑÂêà
        function checkFailedCombosWithIncrements(increments) {
          const stillFailed = [];
          failedCombinations.forEach(combo => {
            let sum = 0;
            combo.elements.forEach(e => {
              sum += currentValues[e.name] + (increments[e.name] || 0);
            });
            if (sum < target) {
              stillFailed.push({
                ...combo,
                currentSum: sum,
                deficit: target - sum
              });
            }
          });
          return stillFailed;
        }

        // È™åËØÅÂ¢ûÂä†ÂÄºÊòØÂê¶Êª°Ë∂≥ÊúÄÂ§ßÂÄºÈôêÂà∂
        function isValidIncrements(increments) {
          for (const [name, inc] of Object.entries(increments)) {
            if (inc < 0) return false;
            if (maxLimits[name] !== null && currentValues[name] + inc > maxLimits[name]) {
              return false;
            }
          }
          return true;
        }

        // ËÆ°ÁÆóÊÄªÂ¢ûÂä†ÂÄº
        function getTotalIncrement(increments) {
          return Object.values(increments).reduce((sum, val) => sum + val, 0);
        }

        // ÂàùÂßãÂåñÊúÄ‰ºòËß£
        let bestSolution = null;
        let minTotalIncrement = Infinity;

        // ÊñπÊ≥ï1ÔºöÊô∫ËÉΩÊûö‰∏æÊêúÁ¥¢ÔºàÈíàÂØπÂ∞èËßÑÊ®°ÈóÆÈ¢òÔºâ
        function intelligentEnumeration() {
          const elementNames = elements.map(e => e.name);
          const maxIncrements = elementNames.map(name => {
            if (maxLimits[name] !== null) {
              return Math.min(maxReasonableIncrement, maxLimits[name] - currentValues[name]);
            }
            return maxReasonableIncrement; // Êó†ÊúÄÂ§ßÂÄºÈôêÂà∂Êó∂‰ΩøÁî®ÂÆåÊï¥ÊêúÁ¥¢ËåÉÂõ¥
          });

          // ‰ºòÂÖàÊêúÁ¥¢ËæÉÂ∞èÁöÑÊÄªÂ¢ûÂä†ÂÄº
          for (let totalInc = 0; totalInc <= maxReasonableIncrement && totalInc < minTotalIncrement; totalInc++) {
            // ÁîüÊàêÊâÄÊúâÂèØËÉΩÁöÑÂ¢ûÂä†ÂÄºÁªÑÂêàÔºåÊÄªÂíå‰∏∫totalInc
            function generateCombinations(remaining, index, current) {
              if (index === elementNames.length) {
                if (remaining === 0) {
                  const increments = {};
                  elementNames.forEach((name, i) => {
                    increments[name] = current[i];
                  });

                  if (isValidIncrements(increments)) {
                    const failed = checkFailedCombosWithIncrements(increments);
                    if (failed.length === 0) {
                      const total = getTotalIncrement(increments);
                      if (total < minTotalIncrement) {
                        minTotalIncrement = total;
                        bestSolution = {
                          increments: { ...increments },
                          totalIncrement: total,
                          failedCount: 0,
                          method: 'intelligent_enumeration'
                        };
                      }
                    }
                  }
                }
                return;
              }

              const maxForThis = Math.min(remaining, maxIncrements[index]);
              for (let i = 0; i <= maxForThis; i++) {
                current[index] = i;
                generateCombinations(remaining - i, index + 1, current);
                if (bestSolution && bestSolution.failedCount === 0) {
                  return; // Â∑≤ÊâæÂà∞ÊúÄ‰ºòËß£ÔºåÊèêÂâçÈÄÄÂá∫
                }
              }
            }

            generateCombinations(totalInc, 0, new Array(elementNames.length));
            if (bestSolution && bestSolution.failedCount === 0) {
              break; // ÊâæÂà∞ÊúÄ‰ºòËß£ÔºåÈÄÄÂá∫
            }
          }
        }

        // ÊñπÊ≥ï2ÔºöÊîπËøõÁöÑË¥™ÂøÉÁÆóÊ≥ïÔºà‰Ωú‰∏∫Â§áÈÄâÔºâ
        function improvedGreedy() {
          const increments = {};
          elements.forEach(e => {
            increments[e.name] = 0;
          });

          let stillFailed = checkFailedCombosWithIncrements(increments);
          const maxIterations = 100;
          let iterations = 0;

          while (stillFailed.length > 0 && iterations < maxIterations) {
            iterations++;

            // ËÆ°ÁÆóÊØè‰∏™ÂÖÉÁ¥†ÁöÑËæπÈôÖÊïàÁõäÔºàÊØèÂ¢ûÂä†1ÁÇπËÉΩËß£ÂÜ≥ÁöÑÁªÑÂêàÊï∞Ôºâ
            let bestChoice = null;
            let maxBenefit = 0;

            elements.forEach(element => {
              const name = element.name;
              const currentTotal = currentValues[name] + increments[name];

              // Ê£ÄÊü•ÊòØÂê¶ÂèØ‰ª•Â¢ûÂä†
              if (maxLimits[name] !== null && currentTotal >= maxLimits[name]) {
                return;
              }

              // ËÆ°ÁÆóÂ¢ûÂä†1ÁÇπÁöÑÊïàÁõä
              const testIncrements = { ...increments };
              testIncrements[name]++;
              const newFailed = checkFailedCombosWithIncrements(testIncrements);
              const benefit = stillFailed.length - newFailed.length;

              if (benefit > maxBenefit) {
                maxBenefit = benefit;
                bestChoice = name;
              }
            });

            // Â¶ÇÊûúÊ≤°ÊúâÊâæÂà∞ÊúâÊïàÁõäÁöÑÈÄâÊã©Ôºå‰ΩÜËøòÊúâÂ§±Ë¥•ÁªÑÂêàÔºåÂº∫Âà∂ÈÄâÊã©‰∏Ä‰∏™ÂèØ‰ª•Â¢ûÂä†ÁöÑÂÖÉÁ¥†
            if (!bestChoice && stillFailed.length > 0) {
              // ÈÄâÊã©Âú®Â§±Ë¥•ÁªÑÂêà‰∏≠Âá∫Áé∞ÊúÄÂ§öÁöÑÂÖÉÁ¥†
              const elementCounts = {};
              elements.forEach(e => {
                elementCounts[e.name] = 0;
              });

              stillFailed.forEach(combo => {
                combo.elements.forEach(e => {
                  const currentTotal = currentValues[e.name] + increments[e.name];
                  // Âè™ÁªüËÆ°ÂèØ‰ª•Â¢ûÂä†ÁöÑÂÖÉÁ¥†
                  if (maxLimits[e.name] === null || currentTotal < maxLimits[e.name]) {
                    elementCounts[e.name]++;
                  }
                });
              });

              // ÊâæÂà∞Âá∫Áé∞Ê¨°Êï∞ÊúÄÂ§öÁöÑÂèØÂ¢ûÂä†ÂÖÉÁ¥†
              let maxCount = 0;
              Object.keys(elementCounts).forEach(name => {
                if (elementCounts[name] > maxCount) {
                  maxCount = elementCounts[name];
                  bestChoice = name;
                }
              });
            }

            if (!bestChoice) {
              break; // ÁúüÁöÑÊó†Ê≥ïÁªßÁª≠‰∫Ü
            }

            increments[bestChoice]++;
            stillFailed = checkFailedCombosWithIncrements(increments);
          }

          // Á≤æÁªÜ‰ºòÂåñ
          let optimized = true;
          while (optimized) {
            optimized = false;
            Object.keys(increments).forEach(name => {
              if (increments[name] > 0) {
                increments[name]--;
                const testFailed = checkFailedCombosWithIncrements(increments);
                if (testFailed.length > 0) {
                  increments[name]++;
                } else {
                  optimized = true;
                }
              }
            });
          }

          const finalFailed = checkFailedCombosWithIncrements(increments);
          const total = getTotalIncrement(increments);

          if (total < minTotalIncrement) {
            minTotalIncrement = total;
            bestSolution = {
              increments: { ...increments },
              totalIncrement: total,
              failedCount: finalFailed.length,
              method: 'improved_greedy'
            };
          }
        }

        // ÁÆÄÂçïË¥™ÂøÉÁÆóÊ≥ï‰Ωú‰∏∫ÊúÄÂêé‰øùÂ∫ï
        function simpleGreedyFallback() {
          const increments = {};
          elements.forEach(e => {
            increments[e.name] = 0;
          });

          // Áõ¥Êé•ËÆ°ÁÆóÊØè‰∏™Â§±Ë¥•ÁªÑÂêàÈúÄË¶ÅÁöÑÊúÄÂ∞èÂ¢ûÂä†ÂÄº
          failedCombinations.forEach(combo => {
            const currentSum = combo.elements.reduce((sum, e) => {
              return sum + currentValues[e.name] + increments[e.name];
            }, 0);

            if (currentSum < target) {
              const deficit = target - currentSum;
              // Âπ≥ÂùáÂàÜÈÖçÂà∞ÁªÑÂêà‰∏≠ÁöÑÊØè‰∏™ÂÖÉÁ¥†
              const avgIncrease = Math.ceil(deficit / combo.elements.length);
              combo.elements.forEach(e => {
                // Ê£ÄÊü•ÊúÄÂ§ßÂÄºÈôêÂà∂
                const currentTotal = currentValues[e.name] + increments[e.name];
                if (maxLimits[e.name] === null || currentTotal + avgIncrease <= maxLimits[e.name]) {
                  increments[e.name] += avgIncrease;
                }
              });
            }
          });

          const finalFailed = checkFailedCombosWithIncrements(increments);
          return {
            increments: { ...increments },
            totalIncrement: getTotalIncrement(increments),
            failedCount: finalFailed.length,
            method: 'simple_greedy_fallback'
          };
        }

        // ËÆ∞ÂΩïÂàùÂßãÂ§±Ë¥•ÁªÑÂêàÊï∞
        const initialFailedCombos = checkFailedCombosWithIncrements({});

        // Ê†πÊçÆÈóÆÈ¢òËßÑÊ®°ÈÄâÊã©ÁÆóÊ≥ï
        if (maxReasonableIncrement <= 25 && elements.length <= 7) {
          // Â∞è‰∏≠ËßÑÊ®°ÈóÆÈ¢òÔºö‰ΩøÁî®Êô∫ËÉΩÊûö‰∏æ
          intelligentEnumeration();
        }

        // ÊÄªÊòØËøêË°åÊîπËøõÁöÑË¥™ÂøÉÁÆóÊ≥ï‰Ωú‰∏∫Â§áÈÄâ
        improvedGreedy();

        // Â¶ÇÊûúÊô∫ËÉΩÊûö‰∏æÂíåÊîπËøõË¥™ÂøÉÈÉΩÊ≤°ÊâæÂà∞ÂÆåÁæéËß£Ôºå‰ΩøÁî®ÁÆÄÂçïË¥™ÂøÉ‰øùÂ∫ï
        if (!bestSolution || bestSolution.failedCount > 0) {
          const simpleGreedySolution = simpleGreedyFallback();
          if (simpleGreedySolution.failedCount < (bestSolution ? bestSolution.failedCount : Infinity)) {
            bestSolution = simpleGreedySolution;
          }
        }

        // Â¶ÇÊûúÊ≤°ÊúâÊâæÂà∞Ëß£ÔºåËøîÂõûÂéüÂßãÁöÑË¥™ÂøÉÁªìÊûú
        if (!bestSolution) {
          bestSolution = {
            increments: {},
            totalIncrement: 0,
            failedCount: initialFailedCombos.length,
            method: 'no_solution'
          };
          elements.forEach(e => {
            bestSolution.increments[e.name] = 0;
          });
        }

        // ÊûÑÂª∫ËØ¶ÁªÜÁöÑÂ§±Ë¥•ÁªÑÂêà‰ø°ÊÅØ
        const finalFailedCombos = checkFailedCombosWithIncrements(bestSolution.increments);
        const failedDetails = finalFailedCombos.map(combo => {
          const names = combo.elements.map(e => e.name).join('+');
          const values = combo.elements.map(e => {
            const inc = bestSolution.increments[e.name] || 0;
            const newVal = e.value + inc;
            return inc > 0 ? `${e.name}(${e.value}‚Üí${newVal})` : `${e.name}(${e.value})`;
          }).join(' + ');
          return {
            names: names,
            values: values,
            currentSum: combo.currentSum,
            deficit: combo.deficit,
            originalDeficit: combo.deficit
          };
        });

        return {
          increments: bestSolution.increments,
          totalIncrement: bestSolution.totalIncrement,
          failedCount: bestSolution.failedCount,
          initialFailedCount: initialFailedCombos.length,
          failedDetails: failedDetails,
          hasMaxLimitIssue: bestSolution.failedCount > 0,
          method: bestSolution.method
        };
      }

      // ÂØªÊâæÊúÄ‰ºòËß£
      const optimalSolution = findOptimalSolution();

      // ÊòæÁ§∫ÊúÄ‰ºòÊñπÊ°à
      if (optimalSolution.totalIncrement > 0 || optimalSolution.failedCount > 0) {
        const suggestion = document.createElement('div');
        suggestion.className = 'optimization-suggestion';

        // ÊûÑÂª∫Ë∞ÉÊï¥ÊñπÊ°àÊñáÊú¨
        const adjustments = [];
        Object.keys(optimalSolution.increments).forEach(name => {
          if (optimalSolution.increments[name] > 0) {
            const element = elements.find(e => e.name === name);
            adjustments.push(`${name}: ${element.value} ‚Üí ${element.value + optimalSolution.increments[name]} (+${optimalSolution.increments[name]})`);
          }
        });

        // Ê£ÄÊü•ÊòØÂê¶ÊúâÂÖÉÁ¥†ËææÂà∞ÊúÄÂ§ßÂÄºÈôêÂà∂
        const limitedElements = [];
        Object.keys(optimalSolution.increments).forEach(name => {
          const element = elements.find(e => e.name === name);
          if (element.maxValue !== null) {
            const newValue = element.value + optimalSolution.increments[name];
            if (newValue >= element.maxValue) {
              limitedElements.push(`${name}(Â∑≤ËææÊúÄÂ§ßÂÄº${element.maxValue})`);
            }
          }
        });

        // ÊûÑÂª∫HTMLÂÜÖÂÆπ
        let htmlContent = `<strong>üí° ÊúÄ‰ºòÂåñÊñπÊ°àÔºàÊúÄÂ∞èÂ¢ûÂä†ÂÄºÊñπÊ°àÔºâÔºö</strong><br>`;

        // ÊòæÁ§∫ÂàùÂßãÂ§±Ë¥•ÊÉÖÂÜµ
        htmlContent += `ÂàùÂßãÁä∂ÊÄÅÔºö<strong>${optimalSolution.initialFailedCount} ‰∏™ÁªÑÂêàÊú™ËææÊ†á</strong><br><br>`;

        if (adjustments.length > 0) {
          htmlContent += `Ë∞ÉÊï¥ÊñπÊ°àÔºö<br>${adjustments.map(a => `‚Ä¢ ${a}`).join('<br>')}<br>`;
          htmlContent += `<strong>ÊÄªÂ¢ûÂä†ÂÄºÔºö${optimalSolution.totalIncrement}</strong><br>`;
        } else if (optimalSolution.failedCount > 0) {
          htmlContent += `<strong>‚ö†Ô∏è Êó†Ê≥ïÈÄöËøáÂ¢ûÂä†ÂÖÉÁ¥†ÂÄºÊù•Êª°Ë∂≥ÊâÄÊúâÁªÑÂêàÔºàÂèØËÉΩÂèóÊúÄÂ§ßÂÄºÈôêÂà∂Ôºâ</strong><br>`;
        }

        if (limitedElements.length > 0) {
          htmlContent += `‚ö†Ô∏è ËææÂà∞ÊúÄÂ§ßÂÄºÈôêÂà∂Ôºö${limitedElements.join('„ÄÅ')}<br>`;
        }

        htmlContent += `<br>‰ºòÂåñÂêéÊïàÊûúÔºö<strong>${optimalSolution.failedCount === 0 ?
          '‚úÖ ÊâÄÊúâÁªÑÂêàÈÉΩËææÂà∞ÁõÆÊ†áÂÄº' :
          `‚ùå ‰ªçÊúâ ${optimalSolution.failedCount} ‰∏™ÁªÑÂêàÊó†Ê≥ïËææÊ†á`}</strong><br>`;

        // Â¶ÇÊûú‰ªçÊúâÂ§±Ë¥•ÁöÑÁªÑÂêàÔºåËØ¶ÁªÜÂàóÂá∫
        if (optimalSolution.failedCount > 0 && optimalSolution.failedDetails) {
          htmlContent += `<br><strong>Êó†Ê≥ïËææÊ†áÁöÑÁªÑÂêàËØ¶ÊÉÖÔºö</strong><br>`;
          htmlContent += '<div style="background-color: #fff3cd; padding: 10px; border-radius: 4px; margin-top: 10px;">';
          optimalSolution.failedDetails.forEach((detail, index) => {
            htmlContent += `${index + 1}. ${detail.values}<br>`;
            htmlContent += `   ÂΩìÂâçÂíå: ${detail.currentSum}, ËøòÂ∑Æ: ${detail.deficit}<br>`;
          });
          htmlContent += '</div>';

          // ËÆ°ÁÆóÈúÄË¶ÅÁöÑÊúÄÂ∞èÂ¢ûÂä†ÂÄº
          const minNeededIncrement = Math.min(...optimalSolution.failedDetails.map(d => d.deficit));
          htmlContent += `<br><strong>üí° Âª∫ËÆÆÔºö</strong>Ëøô‰∫õÁªÑÂêàËá≥Â∞ëËøòÈúÄË¶ÅÂ¢ûÂä† <strong>${minNeededIncrement}</strong> ÁÇπÊâçËÉΩÂÖ®ÈÉ®ËææÊ†á„ÄÇ`;

          // Â¶ÇÊûúÊúâÊúÄÂ§ßÂÄºÈôêÂà∂ÔºåÊèêÁ§∫Áî®Êà∑
          if (limitedElements.length > 0) {
            htmlContent += `<br>Áî±‰∫éÈÉ®ÂàÜÂÖÉÁ¥†Â∑≤ËææÂà∞ÊúÄÂ§ßÂÄºÈôêÂà∂ÔºåÂèØËÉΩÈúÄË¶ÅË∞ÉÊï¥ÊúÄÂ§ßÂÄºËÆæÁΩÆÊàñÊé•ÂèóÈÉ®ÂàÜÁªÑÂêàÊó†Ê≥ïËææÊ†á„ÄÇ`;
          }
        }

        suggestion.innerHTML = htmlContent;
        analysisSection.appendChild(suggestion);
      } else if (failedCombinations.length === 0) {
        const noSolution = document.createElement('div');
        noSolution.className = 'optimization-suggestion';
        noSolution.innerHTML = '<strong>‚úÖ ÂΩìÂâçÈÖçÁΩÆÂ∑≤Êª°Ë∂≥ÊâÄÊúâÁªÑÂêàË¶ÅÊ±ÇÔºåÊó†ÈúÄ‰ºòÂåñ</strong>';
        analysisSection.appendChild(noSolution);
      } else {
        const noSolution = document.createElement('div');
        noSolution.className = 'optimization-suggestion';
        noSolution.innerHTML = '<strong>‚ö†Ô∏è Êú™ÊâæÂà∞ÊúâÊïàÁöÑ‰ºòÂåñÊñπÊ°à</strong>';
        analysisSection.appendChild(noSolution);
      }

      // Ê∑ªÂä†ÊÄªÁªì
      const summary = document.createElement('div');
      summary.style.marginTop = '15px';
      summary.style.padding = '10px';
      summary.style.backgroundColor = '#f8f9fa';
      summary.style.borderRadius = '4px';

      const highestFailElement = sortedElements[0];
      const failurePercentage = (highestFailElement.failureRatio * 100).toFixed(1);

      // ÊûÑÂª∫ÊúÄ‰ºòÊñπÊ°àÊÄªÁªì
      let optimalSummary = '';
      if (optimalSolution && optimalSolution.totalIncrement > 0) {
        const changedElements = [];
        Object.keys(optimalSolution.increments).forEach(name => {
          if (optimalSolution.increments[name] > 0) {
            changedElements.push(`${name}+${optimalSolution.increments[name]}`);
          }
        });
        optimalSummary = `Ë∞ÉÊï¥ ${changedElements.join('„ÄÅ')}ÔºåÊÄªÂ¢ûÂä†ÂÄº ${optimalSolution.totalIncrement}`;
        if (optimalSolution.failedCount === 0) {
          optimalSummary += 'ÔºàÊâÄÊúâÁªÑÂêàËææÊ†áÔºâ';
        } else {
          optimalSummary += `Ôºà‰ªçÊúâ${optimalSolution.failedCount}‰∏™ÁªÑÂêàÊú™ËææÊ†áÔºâ`;
        }
      } else if (failedCombinations.length === 0) {
        optimalSummary = 'ÂΩìÂâçÈÖçÁΩÆÂ∑≤Êª°Ë∂≥ÊâÄÊúâË¶ÅÊ±Ç';
      } else if (optimalSolution.failedCount > 0) {
        optimalSummary = `Êó†Ê≥ïÈÄöËøáÂ¢ûÂä†‰ΩøÊâÄÊúâÁªÑÂêàËææÊ†áÔºà${optimalSolution.failedCount}‰∏™ÁªÑÂêàÂèóÈôêÔºâ`;
      } else {
        optimalSummary = 'ÈúÄË¶ÅËæÉÂ§ßÂπÖÂ∫¶Ë∞ÉÊï¥';
      }

      summary.innerHTML = `
        <strong>üìù ÂàÜÊûêÊÄªÁªìÔºö</strong><br>
        ‚Ä¢ ÂÖ±Êúâ <strong>${failedCombinations.length}</strong> ‰∏™Â§±Ë¥•ÁªÑÂêà<br>
        ‚Ä¢ <strong>${highestFailElement.name}</strong> Â§±Ë¥•ÊØî‰æãÊúÄÈ´òÔºà${failurePercentage}%Ôºå${highestFailElement.failureCount}/${highestFailElement.totalCount}Ê¨°Ôºâ<br>
        ‚Ä¢ ÊúÄ‰ºòÊñπÊ°àÔºö${optimalSummary}
      `;
      analysisSection.appendChild(summary);

      // Ê∑ªÂä†ÁÆóÊ≥ïËØ¥Êòé
      const algorithmNote = document.createElement('div');
      algorithmNote.style.marginTop = '10px';
      algorithmNote.style.padding = '8px';
      algorithmNote.style.backgroundColor = '#e7f3ff';
      algorithmNote.style.borderRadius = '4px';
      algorithmNote.style.fontSize = '0.9em';
      algorithmNote.style.color = '#666';
      algorithmNote.innerHTML = `
        <strong>üìå ÁÆóÊ≥ïËØ¥ÊòéÔºö</strong><br>
        ‚Ä¢ Êú¨ÊñπÊ°àÈááÁî®ÊîπËøõÁöÑÊúÄÂ∞èÂ¢ûÂä†ÂÄº‰ºòÂåñÁÆóÊ≥ïÔºà‰ΩøÁî®‰∫Ü${optimalSolution.method === 'intelligent_enumeration' ? 'Êô∫ËÉΩÊûö‰∏æÊêúÁ¥¢' : 'ÊîπËøõË¥™ÂøÉÁÆóÊ≥ï'}Ôºâ<br>
        ‚Ä¢ ÁõÆÊ†áÔºöÊâæÂà∞ÁúüÊ≠£ÁöÑÂÖ®Â±ÄÊúÄ‰ºòËß£Ôºå‰ΩøÊâÄÊúâÁªÑÂêàÈÉΩËææÂà∞ÁõÆÊ†áÂÄº‰∏îÊÄªÂ¢ûÂä†ÂÄºÊúÄÂ∞è<br>
        ‚Ä¢ Êô∫ËÉΩÊûö‰∏æÔºöÂØπÂ∞èËßÑÊ®°ÈóÆÈ¢òËøõË°åÂÆåÂÖ®ÊêúÁ¥¢Ôºå‰øùËØÅÊâæÂà∞ÊúÄ‰ºòËß£<br>
        ‚Ä¢ ÊîπËøõË¥™ÂøÉÔºöÂü∫‰∫éËæπÈôÖÊïàÁõäÂàÜÊûêÔºåÊØîÂéüÁÆóÊ≥ïÊõ¥Á≤æÁ°Æ<br>
        ‚Ä¢ Á∫¶ÊùüÂ§ÑÁêÜÔºö‰∏•Ê†ºÈÅµÂÆàÊúÄÂ§ßÂÄºÈôêÂà∂ÔºåÁ°Æ‰øùÊñπÊ°àÂèØË°å
      `;
      analysisSection.appendChild(algorithmNote);

      analysisContainer.appendChild(analysisSection);
    }
  </script>

</body>

</html>