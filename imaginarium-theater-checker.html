<!DOCTYPE html>
<html lang="zh">

<head>
  <meta charset="UTF-8">
  <title>å…ƒç´ æ•°å€¼ç»„åˆåˆ†æå™¨ (è‡ªå®šä¹‰ç›®æ ‡ç‰ˆ)</title>
  <!-- html2canvas CDN -->
  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      min-height: 100vh;
      padding: 20px;
      line-height: 1.6;
    }

    .container {
      max-width: 800px;
      margin: 0 auto;
      background: rgba(255, 255, 255, 0.95);
      padding: 40px;
      border-radius: 20px;
      box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
      backdrop-filter: blur(10px);
      position: relative;
      overflow: hidden;
    }

    .container::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(255, 255, 255, 0.1);
      pointer-events: none;
    }

    h2 {
      text-align: center;
      color: #333;
      font-size: 2.5rem;
      margin-bottom: 20px;
      font-weight: 300;
      position: relative;
      z-index: 1;
    }

    p {
      text-align: center;
      color: #666;
      margin-bottom: 25px;
      font-size: 1.1rem;
      opacity: 0.9;
      position: relative;
      z-index: 1;
    }

    .settings-container {
      text-align: center;
      margin-bottom: 30px;
      padding: 25px;
      background: rgba(255, 255, 255, 0.8);
      border-radius: 15px;
      border: 2px solid rgba(102, 126, 234, 0.1);
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
      position: relative;
      z-index: 1;
    }

    .settings-container label {
      font-weight: 600;
      font-size: 1.2em;
      margin-right: 15px;
      color: #333;
      display: inline-block;
      margin-bottom: 10px;
    }

    .settings-container input {
      width: 100px;
      padding: 12px 15px;
      border: 2px solid #e0e6ed;
      border-radius: 10px;
      font-size: 1.1em;
      text-align: center;
      transition: all 0.3s ease;
      background: white;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
    }

    .settings-container input:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
      transform: scale(1.02);
    }

    hr {
      border: none;
      border-top: 2px solid rgba(102, 126, 234, 0.1);
      margin: 30px 0;
      border-radius: 2px;
    }

    #input-container {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 20px;
      margin-bottom: 30px;
      position: relative;
      z-index: 1;
    }

    .input-group {
      display: flex;
      flex-direction: column;
      padding: 20px;
      background: rgba(255, 255, 255, 0.9);
      border-radius: 15px;
      border: 2px solid rgba(102, 126, 234, 0.1);
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }

    .input-group::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(102, 126, 234, 0.1), transparent);
      transition: left 0.5s;
    }

    .input-group:hover {
      transform: translateY(-3px);
      box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
      border-color: #667eea;
    }

    .input-group:hover::before {
      left: 100%;
    }

    .input-group label {
      font-weight: 600;
      margin-bottom: 10px;
      color: #333;
      font-size: 1.1em;
      position: relative;
      z-index: 1;
    }

    .input-group input {
      padding: 12px 15px;
      border: 2px solid #e0e6ed;
      border-radius: 10px;
      font-size: 1em;
      text-align: center;
      margin-bottom: 10px;
      transition: all 0.3s ease;
      background: white;
      position: relative;
      z-index: 1;
    }

    .input-group input:focus {
      outline: none;
      border-color: #667eea;
      box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
      transform: scale(1.02);
    }

    .input-group input:last-child {
      margin-bottom: 0;
    }

    .input-group .max-input {
      background: linear-gradient(135deg, #fff3cd 0%, #fff8e1 100%);
      border-color: #ffc107;
    }

    .input-group .max-input:focus {
      border-color: #ff9800;
      box-shadow: 0 0 0 3px rgba(255, 152, 0, 0.1);
    }

    .input-group .max-label {
      font-size: 0.9em;
      color: #666;
      font-weight: 500;
      margin-top: 5px;
      position: relative;
      z-index: 1;
    }

    button {
      display: block;
      width: 100%;
      padding: 15px 20px;
      font-size: 1.2em;
      font-weight: 600;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      border: none;
      border-radius: 15px;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
      position: relative;
      z-index: 1;
      margin-bottom: 20px;
    }

    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 25px rgba(102, 126, 234, 0.4);
    }

    button:active {
      transform: translateY(0);
      box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
    }

    #result-list {
      margin-top: 30px;
      padding: 0;
      list-style-type: none;
      max-height: 500px;
      overflow-y: auto;
      border: none;
      border-radius: 15px;
      padding: 20px;
      background: rgba(255, 255, 255, 0.9);
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
      backdrop-filter: blur(5px);
      position: relative;
      z-index: 1;
    }

    #result-list::-webkit-scrollbar {
      width: 8px;
    }

    #result-list::-webkit-scrollbar-track {
      background: rgba(0, 0, 0, 0.1);
      border-radius: 4px;
    }

    #result-list::-webkit-scrollbar-thumb {
      background: linear-gradient(135deg, #667eea, #764ba2);
      border-radius: 4px;
    }

    #result-list::-webkit-scrollbar-thumb:hover {
      background: linear-gradient(135deg, #5a6fd8, #6c42a0);
    }

    #result-list li {
      padding: 15px 20px;
      border-bottom: 1px solid rgba(0, 0, 0, 0.05);
      border-radius: 10px;
      margin-bottom: 10px;
      transition: all 0.3s ease;
      position: relative;
      background: rgba(255, 255, 255, 0.5);
    }

    #result-list li:last-child {
      border-bottom: none;
      margin-bottom: 0;
    }

    #result-list li:hover {
      transform: translateX(5px);
      background: rgba(255, 255, 255, 0.8);
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
    }

    .success {
      color: #28a745;
      background: linear-gradient(135deg, rgba(40, 167, 69, 0.1), rgba(40, 167, 69, 0.05));
      border-left: 4px solid #28a745;
    }

    .failure {
      color: #dc3545;
      background: linear-gradient(135deg, rgba(220, 53, 69, 0.1), rgba(220, 53, 69, 0.05));
      border-left: 4px solid #dc3545;
    }

    .analysis-section {
      margin-top: 30px;
      padding: 25px;
      background: rgba(255, 255, 255, 0.9);
      border-radius: 15px;
      border: 2px solid rgba(102, 126, 234, 0.1);
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08);
      backdrop-filter: blur(5px);
      position: relative;
      z-index: 1;
    }

    .analysis-section h3 {
      margin-top: 0;
      color: #333;
      font-size: 1.4em;
      font-weight: 600;
      margin-bottom: 20px;
      padding-bottom: 10px;
      border-bottom: 2px solid rgba(102, 126, 234, 0.1);
    }

    .analysis-section h4 {
      color: #495057;
      font-size: 1.2em;
      font-weight: 600;
      margin: 20px 0 15px 0;
    }

    .frequency-table {
      width: 100%;
      border-collapse: collapse;
      margin: 15px 0;
      background: white;
      border-radius: 10px;
      overflow: hidden;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
    }

    .frequency-table th,
    .frequency-table td {
      padding: 12px 15px;
      text-align: left;
      border-bottom: 1px solid rgba(0, 0, 0, 0.05);
    }

    .frequency-table th {
      background: linear-gradient(135deg, #667eea, #764ba2);
      color: white;
      font-weight: 600;
      font-size: 0.95em;
    }

    .frequency-table tbody tr:hover {
      background: rgba(102, 126, 234, 0.05);
      transform: scale(1.01);
      transition: all 0.3s ease;
    }

    .optimization-suggestion {
      margin-top: 20px;
      padding: 20px;
      background: linear-gradient(135deg, rgba(209, 236, 241, 0.8), rgba(209, 236, 241, 0.6));
      border: 2px solid rgba(190, 229, 235, 0.8);
      border-radius: 15px;
      color: #0c5460;
      box-shadow: 0 5px 15px rgba(0, 0, 0, 0.05);
      position: relative;
      overflow: hidden;
    }

    .optimization-suggestion::before {
      content: 'ğŸ’¡';
      position: absolute;
      top: 15px;
      right: 20px;
      font-size: 1.5em;
      opacity: 0.3;
    }

    .optimization-suggestion strong {
      color: #004085;
      font-weight: 600;
    }

    /* å“åº”å¼è®¾è®¡ */
    @media (max-width: 768px) {
      .container {
        padding: 25px 20px;
        margin: 10px;
      }

      h2 {
        font-size: 2rem;
      }

      #input-container {
        grid-template-columns: 1fr;
        gap: 15px;
      }

      .input-group {
        padding: 15px;
      }

      .settings-container {
        padding: 20px 15px;
      }

      .frequency-table th,
      .frequency-table td {
        padding: 8px 10px;
        font-size: 0.9em;
      }
    }

    /* åŠ¨ç”»æ•ˆæœ */
    .animate-fade-in {
      animation: fadeIn 0.6s ease-out forwards;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(20px);
      }

      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .animate-slide-in {
      animation: slideIn 0.5s ease-out forwards;
    }

    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateX(-20px);
      }

      to {
        opacity: 1;
        transform: translateX(0);
      }
    }

    /* åŠ è½½åŠ¨ç”» */
    .loading {
      position: relative;
    }

    .loading::after {
      content: '';
      position: absolute;
      top: 50%;
      left: 50%;
      width: 20px;
      height: 20px;
      margin: -10px 0 0 -10px;
      border: 2px solid #667eea;
      border-top: 2px solid transparent;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    @keyframes spin {
      to {
        transform: rotate(360deg);
      }
    }
  </style>
</head>

<body>

  <div class="container animate-fade-in">
    <h2>ğŸ­ å…ƒç´ æ•°å€¼ç»„åˆåˆ†æå™¨</h2>

    <div class="settings-container">
      <label for="target-sum-input">ğŸ¯ è®¾ç½®ç›®æ ‡å’Œå€¼:</label>
      <input type="number" id="target-sum-input" value="28" oninput="saveToCache()">
    </div>

    <hr>

    <p>è¯·ä¸º <strong>ğŸ’§æ°´, ğŸ”¥ç«, âš¡é›·, ğŸŒªï¸é£, ğŸ—¿å²©, ğŸŒ¿è‰, â„ï¸å†°</strong> ä¸ƒä¸ªå…ƒç´ åˆ†åˆ«è¾“å…¥å½“å‰å€¼å’Œæœ€å¤§å€¼ï¼ˆå¯é€‰ï¼‰ï¼š</p>
    <div id="input-container">
    </div>

    <button onclick="generateReport()">ğŸ“Š ç”Ÿæˆè¯¦ç»†æŠ¥å‘Š</button>

    <div style="text-align: center; margin: 20px 0;">
      <a href="index.html" style="
        display: inline-flex;
        align-items: center;
        gap: 8px;
        padding: 10px 20px;
        background: rgba(255, 255, 255, 0.8);
        border: 2px solid rgba(102, 126, 234, 0.3);
        border-radius: 25px;
        text-decoration: none;
        color: #667eea;
        font-weight: 600;
        transition: all 0.3s ease;
        backdrop-filter: blur(5px);
      " onmouseover="this.style.background='rgba(102, 126, 234, 0.1)'; this.style.transform='translateY(-2px)'"
        onmouseout="this.style.background='rgba(255, 255, 255, 0.8)'; this.style.transform='translateY(0)'">
        ğŸ  è¿”å›é¦–é¡µ
      </a>
    </div>

    <ul id="result-list"></ul>

    <div id="analysis-container"></div>
  </div>

  <script>
    const identifiers = ['ğŸ’§æ°´', 'ğŸ”¥ç«', 'âš¡é›·', 'ğŸŒªï¸é£', 'ğŸ—¿å²©', 'ğŸŒ¿è‰', 'â„ï¸å†°'];
    const elementNames = ['æ°´', 'ç«', 'é›·', 'é£', 'å²©', 'è‰', 'å†°'];
    const defaultValues = [0, 0, 0, 0, 0, 0, 0];
    const inputContainer = document.getElementById('input-container');

    // é¡µé¢åŠ è½½åŠ¨ç”»
    document.addEventListener('DOMContentLoaded', function () {
      // ä¸ºè¾“å…¥ç»„æ·»åŠ å»¶è¿ŸåŠ¨ç”»
      setTimeout(() => {
        const inputGroups = document.querySelectorAll('.input-group');
        inputGroups.forEach((group, index) => {
          group.style.animationDelay = `${index * 0.1}s`;
          group.classList.add('animate-fade-in');
        });
      }, 300);
    });

    // æœ¬åœ°ç¼“å­˜ç›¸å…³å‡½æ•°
    function saveToCache() {
      const data = {
        targetSum: document.getElementById('target-sum-input').value,
        elements: {},
        maxElements: {}
      };

      identifiers.forEach((name, index) => {
        const input = document.getElementById(`element-${index}`);
        const maxInput = document.getElementById(`element-max-${index}`);
        data.elements[elementNames[index]] = input.value;
        data.maxElements[elementNames[index]] = maxInput.value;
      });

      localStorage.setItem('elementAnalyzerData', JSON.stringify(data));
    }

    function loadFromCache() {
      const cached = localStorage.getItem('elementAnalyzerData');
      if (cached) {
        try {
          const data = JSON.parse(cached);

          // æ¢å¤ç›®æ ‡å’Œå€¼
          if (data.targetSum) {
            document.getElementById('target-sum-input').value = data.targetSum;
          }

          // æ¢å¤å…ƒç´ å€¼
          identifiers.forEach((name, index) => {
            const input = document.getElementById(`element-${index}`);
            const maxInput = document.getElementById(`element-max-${index}`);

            if (data.elements && data.elements[elementNames[index]]) {
              input.value = data.elements[elementNames[index]];
            }

            if (data.maxElements && data.maxElements[elementNames[index]]) {
              maxInput.value = data.maxElements[elementNames[index]];
            }
          });
        } catch (e) {
          console.log('ç¼“å­˜æ•°æ®æ ¼å¼é”™è¯¯ï¼Œä½¿ç”¨é»˜è®¤å€¼');
        }
      }
    }

    // åŠ¨æ€ç”Ÿæˆä¸ƒä¸ªå…ƒç´ çš„è¾“å…¥æ¡†
    identifiers.forEach((name, index) => {
      const group = document.createElement('div');
      group.className = 'input-group';

      const label = document.createElement('label');
      label.htmlFor = `element-${index}`;
      label.textContent = `${name}:`;

      const input = document.createElement('input');
      input.type = 'number';
      input.id = `element-${index}`;
      input.className = 'element-input';
      input.value = defaultValues[index];
      input.placeholder = 'å½“å‰å€¼';
      // æ·»åŠ è¾“å…¥äº‹ä»¶ç›‘å¬å™¨
      input.addEventListener('input', saveToCache);

      const maxLabel = document.createElement('label');
      maxLabel.className = 'max-label';
      maxLabel.htmlFor = `element-max-${index}`;
      maxLabel.textContent = 'æœ€å¤§å€¼ï¼ˆå¯é€‰ï¼‰:';

      const maxInput = document.createElement('input');
      maxInput.type = 'number';
      maxInput.id = `element-max-${index}`;
      maxInput.className = 'element-max-input max-input';
      maxInput.placeholder = 'ä¸é™åˆ¶';
      // æ·»åŠ è¾“å…¥äº‹ä»¶ç›‘å¬å™¨
      maxInput.addEventListener('input', saveToCache);

      group.appendChild(label);
      group.appendChild(input);
      group.appendChild(maxLabel);
      group.appendChild(maxInput);
      inputContainer.appendChild(group);
    });

    // é¡µé¢åŠ è½½æ—¶æ¢å¤ç¼“å­˜æ•°æ®
    window.addEventListener('DOMContentLoaded', loadFromCache);

    function generateReport() {
      // æ·»åŠ åŠ è½½åŠ¨ç”»
      const button = document.querySelector('button');
      const originalText = button.textContent;
      button.textContent = 'ç”Ÿæˆä¸­...';
      button.classList.add('loading');
      button.disabled = true;

      // ä½¿ç”¨setTimeoutè®©åŠ¨ç”»æœ‰æ—¶é—´æ˜¾ç¤º
      setTimeout(() => {
        try {
          performAnalysis();
        } finally {
          // ç§»é™¤åŠ è½½çŠ¶æ€
          button.textContent = originalText;
          button.classList.remove('loading');
          button.disabled = false;
        }
      }, 100);
    }

    function performAnalysis() {
      // 1. è¯»å–è‡ªå®šä¹‰çš„ç›®æ ‡å’Œå€¼
      const targetInput = document.getElementById('target-sum-input');
      const target = parseInt(targetInput.value, 10);

      const resultList = document.getElementById('result-list');
      resultList.innerHTML = ''; // æ¸…ç©ºä¸Šæ¬¡ç»“æœ

      const analysisContainer = document.getElementById('analysis-container');
      analysisContainer.innerHTML = ''; // æ¸…ç©ºä¸Šæ¬¡åˆ†æç»“æœ

      // æ¸…ç†ä¹‹å‰çš„ç®—æ³•è¯´æ˜å’Œä¸‹è½½æŒ‰é’®
      const container = document.querySelector('.container');
      const oldAlgorithmNote = container.querySelector('div[style*="background-color: #e7f3ff"]');
      const oldDownloadBtn = container.querySelector('div[style*="text-align: center"][style*="margin-top: 30px"]');
      if (oldAlgorithmNote) container.removeChild(oldAlgorithmNote);
      if (oldDownloadBtn) container.removeChild(oldDownloadBtn);

      // 2. éªŒè¯ç›®æ ‡å’Œå€¼æ˜¯å¦æœ‰æ•ˆ
      if (isNaN(target)) {
        const li = document.createElement('li');
        li.className = 'failure';
        li.textContent = 'è¾“å…¥æ— æ•ˆï¼Œè¯·ç¡®ä¿"ç›®æ ‡å’Œå€¼"æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„æ•°å­—ã€‚';
        resultList.appendChild(li);
        return;
      }

      // 3. è¯»å–ä¸ƒä¸ªå…ƒç´ çš„æ•°å€¼å’Œæœ€å¤§å€¼
      const inputElements = document.querySelectorAll('.element-input');
      const maxInputElements = document.querySelectorAll('.element-max-input');
      const numbers = Array.from(inputElements).map(input => parseInt(input.value, 10));
      const maxValues = Array.from(maxInputElements).map(input => {
        const val = parseInt(input.value, 10);
        return isNaN(val) ? null : val;
      });

      // 4. éªŒè¯å…ƒç´ æ•°å€¼æ˜¯å¦æœ‰æ•ˆ
      if (numbers.some(isNaN)) {
        const li = document.createElement('li');
        li.className = 'failure';
        li.textContent = 'è¾“å…¥æ— æ•ˆï¼Œè¯·ç¡®ä¿æ‰€æœ‰å…ƒç´ çš„è¾“å…¥æ¡†éƒ½å¡«å†™äº†æœ‰æ•ˆçš„æ•°å­—ã€‚';
        resultList.appendChild(li);
        return;
      }

      // éªŒè¯æœ€å¤§å€¼æ˜¯å¦å¤§äºç­‰äºå½“å‰å€¼
      for (let i = 0; i < numbers.length; i++) {
        if (maxValues[i] !== null && maxValues[i] < numbers[i]) {
          const li = document.createElement('li');
          li.className = 'failure';
          li.textContent = `è¾“å…¥æ— æ•ˆï¼š${identifiers[i]}çš„æœ€å¤§å€¼(${maxValues[i]})ä¸èƒ½å°äºå½“å‰å€¼(${numbers[i]})ã€‚`;
          resultList.appendChild(li);
          return;
        }
      }

      const elements = numbers.map((value, index) => ({
        name: elementNames[index],
        displayName: identifiers[index],
        value: value,
        maxValue: maxValues[index]
      }));

      const failedCombinations = [];
      const elementFailureCount = {};
      const elementTotalCount = {};

      // åˆå§‹åŒ–å…ƒç´ å¤±è´¥è®¡æ•°å’Œæ€»å‡ºç°æ¬¡æ•°
      elementNames.forEach(name => {
        elementFailureCount[name] = 0;
        elementTotalCount[name] = 0;
      });

      // æ”¶é›†æ‰€æœ‰ç»„åˆ
      const allCombinations = [];

      // 5. éå†æ‰€æœ‰ç»„åˆ
      for (let i = 0; i < elements.length - 2; i++) {
        for (let j = i + 1; j < elements.length - 1; j++) {
          for (let k = j + 1; k < elements.length; k++) {
            const elem1 = elements[i];
            const elem2 = elements[j];
            const elem3 = elements[k];

            allCombinations.push({
              elements: [elem1, elem2, elem3],
              sum: elem1.value + elem2.value + elem3.value
            });
          }
        }
      }

      // åˆ¤æ–­ç»„åˆæ˜¯å¦åŒ…å«ç‰¹å®šå…ƒç´ å¯¹
      function hasSpecialPair(combo) {
        const names = combo.elements.map(e => e.name);
        return (names.includes('é£') && names.includes('å²©')) ||
          (names.includes('é£') && names.includes('è‰')) ||
          (names.includes('å²©') && names.includes('è‰'));
      }

      // åˆ†ç¦»æ™®é€šç»„åˆå’Œç‰¹æ®Šç»„åˆ
      const normalCombinations = [];
      const specialCombinations = [];

      allCombinations.forEach(combo => {
        if (hasSpecialPair(combo)) {
          specialCombinations.push(combo);
        } else {
          normalCombinations.push(combo);
        }
      });

      // ç”¨äºç¬¬ä¸€ä»½æŠ¥å‘Šï¼ˆä¸åŒ…å«ç‰¹æ®Šç»„åˆï¼‰çš„ç»Ÿè®¡
      const failedCombinationsNormal = [];
      const elementFailureCountNormal = {};
      const elementTotalCountNormal = {};
      elementNames.forEach(name => {
        elementFailureCountNormal[name] = 0;
        elementTotalCountNormal[name] = 0;
      });

      // ç”ŸæˆæŠ¥å‘Š
      let combinationsCount = 0;

      // å…ˆæ˜¾ç¤ºæ™®é€šç»„åˆ
      normalCombinations.forEach(combo => {
        combinationsCount++;
        const elem1 = combo.elements[0];
        const elem2 = combo.elements[1];
        const elem3 = combo.elements[2];
        const sum = combo.sum;

        // ç»Ÿè®¡å…ƒç´ æ€»å‡ºç°æ¬¡æ•°ï¼ˆä¸¤ä»½ç»Ÿè®¡ï¼‰
        elementTotalCount[elem1.name]++;
        elementTotalCount[elem2.name]++;
        elementTotalCount[elem3.name]++;
        elementTotalCountNormal[elem1.name]++;
        elementTotalCountNormal[elem2.name]++;
        elementTotalCountNormal[elem3.name]++;

        const li = document.createElement('li');
        let text = `${combinationsCount}. ${elem1.displayName}(${elem1.value}) + ${elem2.displayName}(${elem2.value}) + ${elem3.displayName}(${elem3.value}) = <strong>${sum}</strong>. `;

        // ä½¿ç”¨åŠ¨æ€è¯»å–çš„ target å€¼è¿›è¡Œåˆ¤æ–­
        if (sum >= target) {
          li.className = 'success';
          text += `âœ… èƒ½`;
        } else {
          const deficit = target - sum;
          li.className = 'failure';
          text += `âŒ ä¸èƒ½ (éœ€è¦åŠ  ${deficit})`;

          // è®°å½•å¤±è´¥çš„ç»„åˆï¼ˆä¸¤ä»½ç»Ÿè®¡ï¼‰
          failedCombinations.push({
            elements: [elem1, elem2, elem3],
            sum: sum,
            deficit: deficit
          });
          failedCombinationsNormal.push({
            elements: [elem1, elem2, elem3],
            sum: sum,
            deficit: deficit
          });

          // ç»Ÿè®¡å¤±è´¥ç»„åˆä¸­å„å…ƒç´ å‡ºç°æ¬¡æ•°ï¼ˆä¸¤ä»½ç»Ÿè®¡ï¼‰
          elementFailureCount[elem1.name]++;
          elementFailureCount[elem2.name]++;
          elementFailureCount[elem3.name]++;
          elementFailureCountNormal[elem1.name]++;
          elementFailureCountNormal[elem2.name]++;
          elementFailureCountNormal[elem3.name]++;
        }

        li.innerHTML = text;
        li.classList.add('animate-slide-in');
        li.style.animationDelay = `${(combinationsCount - 1) * 0.05}s`;
        resultList.appendChild(li);
      });

      // æ·»åŠ åˆ†ç•Œçº¿
      if (specialCombinations.length > 0) {
        const divider = document.createElement('li');
        divider.style.borderTop = '3px solid #dc3545';
        divider.style.borderBottom = '3px solid #dc3545';
        divider.style.padding = '12px 5px';
        divider.style.margin = '10px 0';
        divider.style.backgroundColor = '#fff3cd';
        divider.style.fontWeight = 'bold';
        divider.style.textAlign = 'center';
        divider.innerHTML = 'âš ï¸ ä»¥ä¸‹æ˜¯åŒ…å«é£å²©ã€é£è‰ã€å²©è‰çš„ç‰¹æ®Šç»„åˆ âš ï¸';
        resultList.appendChild(divider);
      }

      // æ˜¾ç¤ºç‰¹æ®Šç»„åˆ
      specialCombinations.forEach(combo => {
        combinationsCount++;
        const elem1 = combo.elements[0];
        const elem2 = combo.elements[1];
        const elem3 = combo.elements[2];
        const sum = combo.sum;

        // ç»Ÿè®¡å…ƒç´ æ€»å‡ºç°æ¬¡æ•°ï¼ˆåªè®°å½•åˆ°æ€»ç»Ÿè®¡ï¼‰
        elementTotalCount[elem1.name]++;
        elementTotalCount[elem2.name]++;
        elementTotalCount[elem3.name]++;

        const li = document.createElement('li');
        let text = `${combinationsCount}. ${elem1.displayName}(${elem1.value}) + ${elem2.displayName}(${elem2.value}) + ${elem3.displayName}(${elem3.value}) = <strong>${sum}</strong>. `;

        // ä½¿ç”¨åŠ¨æ€è¯»å–çš„ target å€¼è¿›è¡Œåˆ¤æ–­
        if (sum >= target) {
          li.className = 'success';
          text += `âœ… èƒ½`;
        } else {
          const deficit = target - sum;
          li.className = 'failure';
          text += `âŒ ä¸èƒ½ (éœ€è¦åŠ  ${deficit})`;

          // è®°å½•å¤±è´¥çš„ç»„åˆï¼ˆåªè®°å½•åˆ°æ€»ç»Ÿè®¡ï¼‰
          failedCombinations.push({
            elements: [elem1, elem2, elem3],
            sum: sum,
            deficit: deficit
          });

          // ç»Ÿè®¡å¤±è´¥ç»„åˆä¸­å„å…ƒç´ å‡ºç°æ¬¡æ•°ï¼ˆåªè®°å½•åˆ°æ€»ç»Ÿè®¡ï¼‰
          elementFailureCount[elem1.name]++;
          elementFailureCount[elem2.name]++;
          elementFailureCount[elem3.name]++;
        }

        li.innerHTML = text;
        li.classList.add('animate-slide-in');
        li.style.animationDelay = `${(combinationsCount - 1) * 0.05}s`;
        resultList.appendChild(li);
      });

      // ç”Ÿæˆä¸¤ä»½åˆ†ææŠ¥å‘Š
      if (specialCombinations.length > 0) {
        // æœ‰ç‰¹æ®Šç»„åˆæ—¶ï¼šæ˜¾ç¤ºä¸¤ä¸ªæŠ¥å‘Š
        generateAnalysis(elements, failedCombinationsNormal, elementFailureCountNormal, elementTotalCountNormal, target, 'ï¼ˆä¸å«é£å²©ã€é£è‰ã€å²©è‰ç»„åˆï¼‰');
        generateAnalysis(elements, failedCombinations, elementFailureCount, elementTotalCount, target, 'ï¼ˆåŒ…å«æ‰€æœ‰ç»„åˆï¼‰');
      } else {
        // æ²¡æœ‰ç‰¹æ®Šç»„åˆæ—¶ï¼šåªæ˜¾ç¤ºæ™®é€šç»„åˆåˆ†æ
        generateAnalysis(elements, failedCombinationsNormal, elementFailureCountNormal, elementTotalCountNormal, target, 'ï¼ˆä¸å«é£å²©ã€é£è‰ã€å²©è‰ç»„åˆï¼‰');
      }

      // åœ¨æŠ¥å‘ŠåŒºåŸŸå¤–æ·»åŠ ç®—æ³•è¯´æ˜å’Œä¸‹è½½æŒ‰é’®
      addAlgorithmNote();
      addDownloadButton();
    }

    // æ·»åŠ ç®—æ³•è¯´æ˜ï¼ˆåœ¨æŠ¥å‘ŠåŒºåŸŸå¤–ï¼‰
    function addAlgorithmNote() {
      const container = document.querySelector('.container');

      const algorithmNote = document.createElement('div');
      algorithmNote.style.marginTop = '30px';
      algorithmNote.style.padding = '20px';
      algorithmNote.style.backgroundColor = '#e7f3ff';
      algorithmNote.style.borderRadius = '15px';
      algorithmNote.style.fontSize = '0.95em';
      algorithmNote.style.color = '#666';
      algorithmNote.style.border = '2px solid rgba(102, 126, 234, 0.1)';
      algorithmNote.style.boxShadow = '0 5px 15px rgba(0, 0, 0, 0.05)';

      // è·å–æœ€åä¸€æ¬¡è¿è¡Œçš„ç®—æ³•ä¿¡æ¯
      // è¿™é‡Œæˆ‘ä»¬éœ€è¦ä»æœ€è¿‘çš„ä¼˜åŒ–ç»“æœä¸­è·å–æ–¹æ³•ä¿¡æ¯
      algorithmNote.innerHTML = `
        <strong>ğŸ“Œ ç®—æ³•è¯´æ˜ï¼š</strong><br>
        â€¢ æœ¬æ–¹æ¡ˆé‡‡ç”¨æ”¹è¿›çš„æœ€å°å¢åŠ å€¼ä¼˜åŒ–ç®—æ³•<br>
        â€¢ ç›®æ ‡ï¼šæ‰¾åˆ°çœŸæ­£çš„å…¨å±€æœ€ä¼˜è§£ï¼Œä½¿æ‰€æœ‰ç»„åˆéƒ½è¾¾åˆ°ç›®æ ‡å€¼ä¸”æ€»å¢åŠ å€¼æœ€å°<br>
        â€¢ æ™ºèƒ½æšä¸¾ï¼šå¯¹å°è§„æ¨¡é—®é¢˜è¿›è¡Œå®Œå…¨æœç´¢ï¼Œä¿è¯æ‰¾åˆ°æœ€ä¼˜è§£<br>
        â€¢ æ”¹è¿›è´ªå¿ƒï¼šåŸºäºè¾¹é™…æ•ˆç›Šåˆ†æï¼Œæ¯”åŸç®—æ³•æ›´ç²¾ç¡®<br>
        â€¢ çº¦æŸå¤„ç†ï¼šä¸¥æ ¼éµå®ˆæœ€å¤§å€¼é™åˆ¶ï¼Œç¡®ä¿æ–¹æ¡ˆå¯è¡Œ
      `;

      container.appendChild(algorithmNote);
    }

    // æ·»åŠ ä¸‹è½½æŒ‰é’®åˆ°åˆ†æå®¹å™¨
    function addDownloadButton() {
      const container = document.querySelector('.container');
      const analysisContainer = document.getElementById('analysis-container');

      const downloadContainer = document.createElement('div');
      downloadContainer.style.textAlign = 'center';
      downloadContainer.style.marginTop = '30px';
      downloadContainer.style.padding = '20px';

      const downloadBtn = document.createElement('button');
      downloadBtn.textContent = 'ğŸ“¸ ä¸‹è½½åˆ†ææŠ¥å‘Šé•¿å›¾';
      downloadBtn.style.padding = '12px 24px';
      downloadBtn.style.fontSize = '1.1em';
      downloadBtn.style.background = 'linear-gradient(135deg, #28a745, #20c997)';
      downloadBtn.style.color = 'white';
      downloadBtn.style.border = 'none';
      downloadBtn.style.borderRadius = '12px';
      downloadBtn.style.cursor = 'pointer';
      downloadBtn.style.boxShadow = '0 4px 15px rgba(40, 167, 69, 0.3)';
      downloadBtn.style.transition = 'all 0.3s ease';
      downloadBtn.style.fontWeight = '600';

      downloadBtn.onmouseover = function() {
        this.style.transform = 'translateY(-3px)';
        this.style.boxShadow = '0 6px 20px rgba(40, 167, 69, 0.4)';
      };
      downloadBtn.onmouseout = function() {
        this.style.transform = 'translateY(0)';
        this.style.boxShadow = '0 4px 15px rgba(40, 167, 69, 0.3)';
      };

      downloadBtn.onclick = function() {
        // åªä¸‹è½½åˆ†ææŠ¥å‘ŠåŒºåŸŸï¼Œä¸åŒ…æ‹¬ç®—æ³•è¯´æ˜å’ŒæŒ‰é’®
        generateReportImage(analysisContainer, 'åˆ†ææŠ¥å‘Š');
      };

      downloadContainer.appendChild(downloadBtn);
      container.appendChild(downloadContainer);
    }

    function generateAnalysis(elements, failedCombinations, elementFailureCount, elementTotalCount, target, reportType = '') {
      const analysisContainer = document.getElementById('analysis-container');

      // åˆ›å»ºåˆ†æåŒºåŸŸ
      const analysisSection = document.createElement('div');
      analysisSection.className = 'analysis-section';

      // æ·»åŠ æ ‡é¢˜
      const title = document.createElement('h3');
      if (failedCombinations.length === 0) {
        title.textContent = `ğŸ“Š ç»„åˆåˆ†ææŠ¥å‘Š ${reportType}`;
      } else {
        title.textContent = `ğŸ“Š å¤±è´¥ç»„åˆåˆ†ææŠ¥å‘Š ${reportType}`;
      }
      analysisSection.appendChild(title);

      // 1. å…ƒç´ å¤±è´¥æ¯”ä¾‹ç»Ÿè®¡
      const freqTitle = document.createElement('h4');
      if (failedCombinations.length === 0) {
        freqTitle.textContent = '1. å…ƒç´ ç»Ÿè®¡åˆ†æï¼š';
      } else {
        freqTitle.textContent = '1. å…ƒç´ å¤±è´¥æ¯”ä¾‹åˆ†æï¼š';
      }
      analysisSection.appendChild(freqTitle);

      if (failedCombinations.length === 0) {
        // å¦‚æœæ²¡æœ‰å¤±è´¥ç»„åˆï¼Œæ˜¾ç¤ºæˆåŠŸæç¤º
        const successMsg = document.createElement('div');
        successMsg.style.padding = '20px';
        successMsg.style.backgroundColor = '#d4edda';
        successMsg.style.border = '2px solid #c3e6cb';
        successMsg.style.borderRadius = '10px';
        successMsg.style.color = '#155724';
        successMsg.style.textAlign = 'center';
        successMsg.style.fontSize = '1.2em';
        successMsg.style.fontWeight = 'bold';
        successMsg.innerHTML = 'ğŸ‰ æ­å–œï¼å½“å‰é…ç½®ä¸‹æ‰€æœ‰ç»„åˆéƒ½èƒ½è¾¾åˆ°ç›®æ ‡å€¼ï¼Œæ— éœ€ä¼˜åŒ–ï¼';
        analysisSection.appendChild(successMsg);

        // ä»ç„¶æ˜¾ç¤ºå…ƒç´ ç»Ÿè®¡è¡¨æ ¼
        const statsNote = document.createElement('div');
        statsNote.style.marginTop = '15px';
        statsNote.style.padding = '10px';
        statsNote.style.backgroundColor = '#f8f9fa';
        statsNote.style.borderRadius = '5px';
        statsNote.style.fontSize = '0.9em';
        statsNote.innerHTML = '<strong>ğŸ“Š å…ƒç´ ç»Ÿè®¡æ¦‚è§ˆï¼š</strong>';
        analysisSection.appendChild(statsNote);
      }

      // åˆ›å»ºé¢‘ç‡è¡¨æ ¼
      const table = document.createElement('table');
      table.className = 'frequency-table';

      const thead = document.createElement('thead');
      if (failedCombinations.length === 0) {
        thead.innerHTML = '<tr><th>å…ƒç´ </th><th>å½“å‰å€¼</th><th>æ€»å‡ºç°æ¬¡æ•°</th><th>æˆåŠŸæ¬¡æ•°</th><th>æˆåŠŸæ¯”ä¾‹</th><th>æˆåŠŸæ¯”ä¾‹æ’å</th></tr>';
      } else {
        thead.innerHTML = '<tr><th>å…ƒç´ </th><th>å½“å‰å€¼</th><th>æ€»å‡ºç°æ¬¡æ•°</th><th>å¤±è´¥æ¬¡æ•°</th><th>å¤±è´¥æ¯”ä¾‹</th><th>å¤±è´¥æ¯”ä¾‹æ’å</th></tr>';
      }
      table.appendChild(thead);

      const tbody = document.createElement('tbody');

      // è®¡ç®—å¤±è´¥æ¯”ä¾‹å¹¶æŒ‰å¤±è´¥æ¯”ä¾‹æ’åº
      const elementStats = Object.entries(elementFailureCount)
        .map(entry => {
          const name = entry[0];
          const failureCount = entry[1];
          const totalCount = elementTotalCount[name];
          const failureRatio = totalCount > 0 ? (failureCount / totalCount) : 0;
          const successRatio = totalCount > 0 ? ((totalCount - failureCount) / totalCount) : 0;
          return {
            name: name,
            failureCount: failureCount,
            totalCount: totalCount,
            failureRatio: failureRatio,
            successRatio: successRatio,
            value: elements.find(e => e.name === name).value
          };
        })
        .sort((a, b) => {
          if (failedCombinations.length === 0) {
            return b.successRatio - a.successRatio; // æŒ‰æˆåŠŸç‡é™åºæ’åˆ—
          } else {
            return b.failureRatio - a.failureRatio; // æŒ‰å¤±è´¥ç‡é™åºæ’åˆ—
          }
        })
        .map((elem, index) => ({
          ...elem,
          rank: index + 1
        }));

      const sortedElements = elementStats;

      sortedElements.forEach(elem => {
        const row = document.createElement('tr');
        if (elem.rank === 1 && failedCombinations.length === 0) {
          row.style.backgroundColor = '#d4edda'; // æˆåŠŸæ—¶ç”¨ç»¿è‰²
        } else if (elem.rank === 1) {
          row.style.backgroundColor = '#fff3cd'; // å¤±è´¥æ—¶ç”¨é»„è‰²
        }

        if (failedCombinations.length === 0) {
          // æ˜¾ç¤ºæˆåŠŸç‡
          const successCount = elem.totalCount - elem.failureCount;
          const percentageStr = (elem.successRatio * 100).toFixed(1);
          row.innerHTML = `
            <td><strong>${elem.name}</strong></td>
            <td>${elem.value}</td>
            <td>${elem.totalCount}</td>
            <td>${successCount}</td>
            <td>${percentageStr}%</td>
            <td>${elem.rank === 1 ? 'ğŸ¥‡ ç¬¬ä¸€' : elem.rank === 2 ? 'ğŸ¥ˆ ç¬¬äºŒ' : elem.rank === 3 ? 'ğŸ¥‰ ç¬¬ä¸‰' : `ç¬¬${elem.rank}`}</td>
          `;
        } else {
          // æ˜¾ç¤ºå¤±è´¥ç‡
          const percentageStr = (elem.failureRatio * 100).toFixed(1);
          row.innerHTML = `
            <td><strong>${elem.name}</strong></td>
            <td>${elem.value}</td>
            <td>${elem.totalCount}</td>
            <td>${elem.failureCount}</td>
            <td>${percentageStr}%</td>
            <td>${elem.rank === 1 ? 'ğŸ¥‡ ç¬¬ä¸€' : elem.rank === 2 ? 'ğŸ¥ˆ ç¬¬äºŒ' : elem.rank === 3 ? 'ğŸ¥‰ ç¬¬ä¸‰' : `ç¬¬${elem.rank}`}</td>
          `;
        }
        tbody.appendChild(row);
      });

      table.appendChild(tbody);
      analysisSection.appendChild(table);

      // 2. æœ€ä¼˜åŒ–å»ºè®®
      const optTitle = document.createElement('h4');
      optTitle.textContent = '2. æ€§ä»·æ¯”æœ€ä¼˜æ–¹æ¡ˆï¼š';
      analysisSection.appendChild(optTitle);

      // ä½¿ç”¨æ”¹è¿›çš„æœ€å°å¢åŠ å€¼ä¼˜åŒ–ç®—æ³•
      function findOptimalSolution() {
        // å¤åˆ¶å½“å‰å…ƒç´ å€¼å’Œæœ€å¤§å€¼é™åˆ¶
        const currentValues = {};
        const maxLimits = {};
        elements.forEach(e => {
          currentValues[e.name] = e.value;
          maxLimits[e.name] = e.maxValue;
        });

        // è·å–æœ€å¤§å¯èƒ½çš„å¢åŠ å€¼èŒƒå›´ï¼ˆç”¨äºæšä¸¾æœç´¢ï¼‰
        const maxReasonableIncrement = Math.max(...failedCombinations.map(c => c.deficit));

        // æ£€æŸ¥ç»™å®šå¢åŠ å€¼ç»„åˆä¸‹çš„å¤±è´¥ç»„åˆ
        function checkFailedCombosWithIncrements(increments) {
          const stillFailed = [];
          failedCombinations.forEach(combo => {
            let sum = 0;
            combo.elements.forEach(e => {
              sum += currentValues[e.name] + (increments[e.name] || 0);
            });
            if (sum < target) {
              stillFailed.push({
                ...combo,
                currentSum: sum,
                deficit: target - sum
              });
            }
          });
          return stillFailed;
        }

        // éªŒè¯å¢åŠ å€¼æ˜¯å¦æ»¡è¶³æœ€å¤§å€¼é™åˆ¶
        function isValidIncrements(increments) {
          for (const [name, inc] of Object.entries(increments)) {
            if (inc < 0) return false;
            if (maxLimits[name] !== null && currentValues[name] + inc > maxLimits[name]) {
              return false;
            }
          }
          return true;
        }

        // è®¡ç®—æ€»å¢åŠ å€¼
        function getTotalIncrement(increments) {
          return Object.values(increments).reduce((sum, val) => sum + val, 0);
        }

        // åˆå§‹åŒ–æœ€ä¼˜è§£
        let bestSolution = null;
        let minTotalIncrement = Infinity;

        // æ–¹æ³•1ï¼šæ™ºèƒ½æšä¸¾æœç´¢ï¼ˆé’ˆå¯¹å°è§„æ¨¡é—®é¢˜ï¼‰
        function intelligentEnumeration() {
          const elementNames = elements.map(e => e.name);
          const maxIncrements = elementNames.map(name => {
            if (maxLimits[name] !== null) {
              return Math.min(maxReasonableIncrement, maxLimits[name] - currentValues[name]);
            }
            return maxReasonableIncrement; // æ— æœ€å¤§å€¼é™åˆ¶æ—¶ä½¿ç”¨å®Œæ•´æœç´¢èŒƒå›´
          });

          // ä¼˜å…ˆæœç´¢è¾ƒå°çš„æ€»å¢åŠ å€¼
          for (let totalInc = 0; totalInc <= maxReasonableIncrement && totalInc < minTotalIncrement; totalInc++) {
            // ç”Ÿæˆæ‰€æœ‰å¯èƒ½çš„å¢åŠ å€¼ç»„åˆï¼Œæ€»å’Œä¸ºtotalInc
            function generateCombinations(remaining, index, current) {
              if (index === elementNames.length) {
                if (remaining === 0) {
                  const increments = {};
                  elementNames.forEach((name, i) => {
                    increments[name] = current[i];
                  });

                  if (isValidIncrements(increments)) {
                    const failed = checkFailedCombosWithIncrements(increments);
                    if (failed.length === 0) {
                      const total = getTotalIncrement(increments);
                      if (total < minTotalIncrement) {
                        minTotalIncrement = total;
                        bestSolution = {
                          increments: { ...increments },
                          totalIncrement: total,
                          failedCount: 0,
                          method: 'intelligent_enumeration'
                        };
                      }
                    }
                  }
                }
                return;
              }

              const maxForThis = Math.min(remaining, maxIncrements[index]);
              for (let i = 0; i <= maxForThis; i++) {
                current[index] = i;
                generateCombinations(remaining - i, index + 1, current);
                if (bestSolution && bestSolution.failedCount === 0) {
                  return; // å·²æ‰¾åˆ°æœ€ä¼˜è§£ï¼Œæå‰é€€å‡º
                }
              }
            }

            generateCombinations(totalInc, 0, new Array(elementNames.length));
            if (bestSolution && bestSolution.failedCount === 0) {
              break; // æ‰¾åˆ°æœ€ä¼˜è§£ï¼Œé€€å‡º
            }
          }
        }

        // æ–¹æ³•2ï¼šæ”¹è¿›çš„è´ªå¿ƒç®—æ³•ï¼ˆä½œä¸ºå¤‡é€‰ï¼‰
        function improvedGreedy() {
          const increments = {};
          elements.forEach(e => {
            increments[e.name] = 0;
          });

          let stillFailed = checkFailedCombosWithIncrements(increments);
          const maxIterations = 100;
          let iterations = 0;

          while (stillFailed.length > 0 && iterations < maxIterations) {
            iterations++;

            // è®¡ç®—æ¯ä¸ªå…ƒç´ çš„è¾¹é™…æ•ˆç›Šï¼ˆæ¯å¢åŠ 1ç‚¹èƒ½è§£å†³çš„ç»„åˆæ•°ï¼‰
            let bestChoice = null;
            let maxBenefit = 0;

            elements.forEach(element => {
              const name = element.name;
              const currentTotal = currentValues[name] + increments[name];

              // æ£€æŸ¥æ˜¯å¦å¯ä»¥å¢åŠ 
              if (maxLimits[name] !== null && currentTotal >= maxLimits[name]) {
                return;
              }

              // è®¡ç®—å¢åŠ 1ç‚¹çš„æ•ˆç›Š
              const testIncrements = { ...increments };
              testIncrements[name]++;
              const newFailed = checkFailedCombosWithIncrements(testIncrements);
              const benefit = stillFailed.length - newFailed.length;

              if (benefit > maxBenefit) {
                maxBenefit = benefit;
                bestChoice = name;
              }
            });

            // å¦‚æœæ²¡æœ‰æ‰¾åˆ°æœ‰æ•ˆç›Šçš„é€‰æ‹©ï¼Œä½†è¿˜æœ‰å¤±è´¥ç»„åˆï¼Œå¼ºåˆ¶é€‰æ‹©ä¸€ä¸ªå¯ä»¥å¢åŠ çš„å…ƒç´ 
            if (!bestChoice && stillFailed.length > 0) {
              // é€‰æ‹©åœ¨å¤±è´¥ç»„åˆä¸­å‡ºç°æœ€å¤šçš„å…ƒç´ 
              const elementCounts = {};
              elements.forEach(e => {
                elementCounts[e.name] = 0;
              });

              stillFailed.forEach(combo => {
                combo.elements.forEach(e => {
                  const currentTotal = currentValues[e.name] + increments[e.name];
                  // åªç»Ÿè®¡å¯ä»¥å¢åŠ çš„å…ƒç´ 
                  if (maxLimits[e.name] === null || currentTotal < maxLimits[e.name]) {
                    elementCounts[e.name]++;
                  }
                });
              });

              // æ‰¾åˆ°å‡ºç°æ¬¡æ•°æœ€å¤šçš„å¯å¢åŠ å…ƒç´ 
              let maxCount = 0;
              Object.keys(elementCounts).forEach(name => {
                if (elementCounts[name] > maxCount) {
                  maxCount = elementCounts[name];
                  bestChoice = name;
                }
              });
            }

            if (!bestChoice) {
              break; // çœŸçš„æ— æ³•ç»§ç»­äº†
            }

            increments[bestChoice]++;
            stillFailed = checkFailedCombosWithIncrements(increments);
          }

          // ç²¾ç»†ä¼˜åŒ–
          let optimized = true;
          while (optimized) {
            optimized = false;
            Object.keys(increments).forEach(name => {
              if (increments[name] > 0) {
                increments[name]--;
                const testFailed = checkFailedCombosWithIncrements(increments);
                if (testFailed.length > 0) {
                  increments[name]++;
                } else {
                  optimized = true;
                }
              }
            });
          }

          const finalFailed = checkFailedCombosWithIncrements(increments);
          const total = getTotalIncrement(increments);

          if (total < minTotalIncrement) {
            minTotalIncrement = total;
            bestSolution = {
              increments: { ...increments },
              totalIncrement: total,
              failedCount: finalFailed.length,
              method: 'improved_greedy'
            };
          }
        }

        // ç®€å•è´ªå¿ƒç®—æ³•ä½œä¸ºæœ€åä¿åº•
        function simpleGreedyFallback() {
          const increments = {};
          elements.forEach(e => {
            increments[e.name] = 0;
          });

          // ç›´æ¥è®¡ç®—æ¯ä¸ªå¤±è´¥ç»„åˆéœ€è¦çš„æœ€å°å¢åŠ å€¼
          failedCombinations.forEach(combo => {
            const currentSum = combo.elements.reduce((sum, e) => {
              return sum + currentValues[e.name] + increments[e.name];
            }, 0);

            if (currentSum < target) {
              const deficit = target - currentSum;
              // å¹³å‡åˆ†é…åˆ°ç»„åˆä¸­çš„æ¯ä¸ªå…ƒç´ 
              const avgIncrease = Math.ceil(deficit / combo.elements.length);
              combo.elements.forEach(e => {
                // æ£€æŸ¥æœ€å¤§å€¼é™åˆ¶
                const currentTotal = currentValues[e.name] + increments[e.name];
                if (maxLimits[e.name] === null || currentTotal + avgIncrease <= maxLimits[e.name]) {
                  increments[e.name] += avgIncrease;
                }
              });
            }
          });

          const finalFailed = checkFailedCombosWithIncrements(increments);
          return {
            increments: { ...increments },
            totalIncrement: getTotalIncrement(increments),
            failedCount: finalFailed.length,
            method: 'simple_greedy_fallback'
          };
        }

        // è®°å½•åˆå§‹å¤±è´¥ç»„åˆæ•°
        const initialFailedCombos = checkFailedCombosWithIncrements({});

        // æ ¹æ®é—®é¢˜è§„æ¨¡é€‰æ‹©ç®—æ³•
        if (maxReasonableIncrement <= 25 && elements.length <= 7) {
          // å°ä¸­è§„æ¨¡é—®é¢˜ï¼šä½¿ç”¨æ™ºèƒ½æšä¸¾
          intelligentEnumeration();
        }

        // æ€»æ˜¯è¿è¡Œæ”¹è¿›çš„è´ªå¿ƒç®—æ³•ä½œä¸ºå¤‡é€‰
        improvedGreedy();

        // å¦‚æœæ™ºèƒ½æšä¸¾å’Œæ”¹è¿›è´ªå¿ƒéƒ½æ²¡æ‰¾åˆ°å®Œç¾è§£ï¼Œä½¿ç”¨ç®€å•è´ªå¿ƒä¿åº•
        if (!bestSolution || bestSolution.failedCount > 0) {
          const simpleGreedySolution = simpleGreedyFallback();
          if (simpleGreedySolution.failedCount < (bestSolution ? bestSolution.failedCount : Infinity)) {
            bestSolution = simpleGreedySolution;
          }
        }

        // å¦‚æœæ²¡æœ‰æ‰¾åˆ°è§£ï¼Œè¿”å›åŸå§‹çš„è´ªå¿ƒç»“æœ
        if (!bestSolution) {
          bestSolution = {
            increments: {},
            totalIncrement: 0,
            failedCount: initialFailedCombos.length,
            method: 'no_solution'
          };
          elements.forEach(e => {
            bestSolution.increments[e.name] = 0;
          });
        }

        // æ„å»ºè¯¦ç»†çš„å¤±è´¥ç»„åˆä¿¡æ¯
        const finalFailedCombos = checkFailedCombosWithIncrements(bestSolution.increments);
        const failedDetails = finalFailedCombos.map(combo => {
          const names = combo.elements.map(e => e.name).join('+');
          const values = combo.elements.map(e => {
            const inc = bestSolution.increments[e.name] || 0;
            const newVal = e.value + inc;
            return inc > 0 ? `${e.name}(${e.value}â†’${newVal})` : `${e.name}(${e.value})`;
          }).join(' + ');
          return {
            names: names,
            values: values,
            currentSum: combo.currentSum,
            deficit: combo.deficit,
            originalDeficit: combo.deficit
          };
        });

        return {
          increments: bestSolution.increments,
          totalIncrement: bestSolution.totalIncrement,
          failedCount: bestSolution.failedCount,
          initialFailedCount: initialFailedCombos.length,
          failedDetails: failedDetails,
          hasMaxLimitIssue: bestSolution.failedCount > 0,
          method: bestSolution.method
        };
      }

      // å¯»æ‰¾æœ€ä¼˜è§£
      const optimalSolution = findOptimalSolution();

      // æ˜¾ç¤ºæœ€ä¼˜æ–¹æ¡ˆ
      if (optimalSolution.totalIncrement > 0 || optimalSolution.failedCount > 0) {
        const suggestion = document.createElement('div');
        suggestion.className = 'optimization-suggestion';

        // æ„å»ºè°ƒæ•´æ–¹æ¡ˆæ–‡æœ¬
        const adjustments = [];
        Object.keys(optimalSolution.increments).forEach(name => {
          if (optimalSolution.increments[name] > 0) {
            const element = elements.find(e => e.name === name);
            adjustments.push(`${name}: ${element.value} â†’ ${element.value + optimalSolution.increments[name]} (+${optimalSolution.increments[name]})`);
          }
        });

        // æ£€æŸ¥æ˜¯å¦æœ‰å…ƒç´ è¾¾åˆ°æœ€å¤§å€¼é™åˆ¶
        const limitedElements = [];
        Object.keys(optimalSolution.increments).forEach(name => {
          const element = elements.find(e => e.name === name);
          if (element.maxValue !== null) {
            const newValue = element.value + optimalSolution.increments[name];
            if (newValue >= element.maxValue) {
              limitedElements.push(`${name}(å·²è¾¾æœ€å¤§å€¼${element.maxValue})`);
            }
          }
        });

        // æ„å»ºHTMLå†…å®¹
        let htmlContent = `<strong>ğŸ’¡ æœ€ä¼˜åŒ–æ–¹æ¡ˆï¼ˆæœ€å°å¢åŠ å€¼æ–¹æ¡ˆï¼‰ï¼š</strong><br>`;

        // æ˜¾ç¤ºåˆå§‹å¤±è´¥æƒ…å†µ
        htmlContent += `åˆå§‹çŠ¶æ€ï¼š<strong>${optimalSolution.initialFailedCount} ä¸ªç»„åˆæœªè¾¾æ ‡</strong><br><br>`;

        if (adjustments.length > 0) {
          htmlContent += `è°ƒæ•´æ–¹æ¡ˆï¼š<br>${adjustments.map(a => `â€¢ ${a}`).join('<br>')}<br>`;
          htmlContent += `<strong>æ€»å¢åŠ å€¼ï¼š${optimalSolution.totalIncrement}</strong><br>`;
        } else if (optimalSolution.failedCount > 0) {
          htmlContent += `<strong>âš ï¸ æ— æ³•é€šè¿‡å¢åŠ å…ƒç´ å€¼æ¥æ»¡è¶³æ‰€æœ‰ç»„åˆï¼ˆå¯èƒ½å—æœ€å¤§å€¼é™åˆ¶ï¼‰</strong><br>`;
        }

        if (limitedElements.length > 0) {
          htmlContent += `âš ï¸ è¾¾åˆ°æœ€å¤§å€¼é™åˆ¶ï¼š${limitedElements.join('ã€')}<br>`;
        }

        htmlContent += `<br>ä¼˜åŒ–åæ•ˆæœï¼š<strong>${optimalSolution.failedCount === 0 ?
          'âœ… æ‰€æœ‰ç»„åˆéƒ½è¾¾åˆ°ç›®æ ‡å€¼' :
          `âŒ ä»æœ‰ ${optimalSolution.failedCount} ä¸ªç»„åˆæ— æ³•è¾¾æ ‡`}</strong><br>`;

        // å¦‚æœä»æœ‰å¤±è´¥çš„ç»„åˆï¼Œè¯¦ç»†åˆ—å‡º
        if (optimalSolution.failedCount > 0 && optimalSolution.failedDetails) {
          htmlContent += `<br><strong>æ— æ³•è¾¾æ ‡çš„ç»„åˆè¯¦æƒ…ï¼š</strong><br>`;
          htmlContent += '<div style="background-color: #fff3cd; padding: 10px; border-radius: 4px; margin-top: 10px;">';
          optimalSolution.failedDetails.forEach((detail, index) => {
            htmlContent += `${index + 1}. ${detail.values}<br>`;
            htmlContent += `   å½“å‰å’Œ: ${detail.currentSum}, è¿˜å·®: ${detail.deficit}<br>`;
          });
          htmlContent += '</div>';

          // è®¡ç®—éœ€è¦çš„æœ€å°å¢åŠ å€¼
          const minNeededIncrement = Math.min(...optimalSolution.failedDetails.map(d => d.deficit));
          htmlContent += `<br><strong>ğŸ’¡ å»ºè®®ï¼š</strong>è¿™äº›ç»„åˆè‡³å°‘è¿˜éœ€è¦å¢åŠ  <strong>${minNeededIncrement}</strong> ç‚¹æ‰èƒ½å…¨éƒ¨è¾¾æ ‡ã€‚`;

          // å¦‚æœæœ‰æœ€å¤§å€¼é™åˆ¶ï¼Œæç¤ºç”¨æˆ·
          if (limitedElements.length > 0) {
            htmlContent += `<br>ç”±äºéƒ¨åˆ†å…ƒç´ å·²è¾¾åˆ°æœ€å¤§å€¼é™åˆ¶ï¼Œå¯èƒ½éœ€è¦è°ƒæ•´æœ€å¤§å€¼è®¾ç½®æˆ–æ¥å—éƒ¨åˆ†ç»„åˆæ— æ³•è¾¾æ ‡ã€‚`;
          }
        }

        suggestion.innerHTML = htmlContent;
        analysisSection.appendChild(suggestion);
      } else if (failedCombinations.length === 0) {
        const noSolution = document.createElement('div');
        noSolution.className = 'optimization-suggestion';
        noSolution.innerHTML = '<strong>âœ… å½“å‰é…ç½®å·²æ»¡è¶³æ‰€æœ‰ç»„åˆè¦æ±‚ï¼Œæ— éœ€ä¼˜åŒ–</strong>';
        analysisSection.appendChild(noSolution);
      } else {
        const noSolution = document.createElement('div');
        noSolution.className = 'optimization-suggestion';
        noSolution.innerHTML = '<strong>âš ï¸ æœªæ‰¾åˆ°æœ‰æ•ˆçš„ä¼˜åŒ–æ–¹æ¡ˆ</strong>';
        analysisSection.appendChild(noSolution);
      }

      // æ·»åŠ æ€»ç»“
      const summary = document.createElement('div');
      summary.style.marginTop = '15px';
      summary.style.padding = '10px';
      summary.style.backgroundColor = '#f8f9fa';
      summary.style.borderRadius = '4px';

      const highestFailElement = sortedElements[0];
      const failurePercentage = (highestFailElement.failureRatio * 100).toFixed(1);

      // æ„å»ºæœ€ä¼˜æ–¹æ¡ˆæ€»ç»“
      let optimalSummary = '';
      if (optimalSolution && optimalSolution.totalIncrement > 0) {
        const changedElements = [];
        Object.keys(optimalSolution.increments).forEach(name => {
          if (optimalSolution.increments[name] > 0) {
            changedElements.push(`${name}+${optimalSolution.increments[name]}`);
          }
        });
        optimalSummary = `è°ƒæ•´ ${changedElements.join('ã€')}ï¼Œæ€»å¢åŠ å€¼ ${optimalSolution.totalIncrement}`;
        if (optimalSolution.failedCount === 0) {
          optimalSummary += 'ï¼ˆæ‰€æœ‰ç»„åˆè¾¾æ ‡ï¼‰';
        } else {
          optimalSummary += `ï¼ˆä»æœ‰${optimalSolution.failedCount}ä¸ªç»„åˆæœªè¾¾æ ‡ï¼‰`;
        }
      } else if (failedCombinations.length === 0) {
        optimalSummary = 'å½“å‰é…ç½®å·²æ»¡è¶³æ‰€æœ‰è¦æ±‚';
      } else if (optimalSolution.failedCount > 0) {
        optimalSummary = `æ— æ³•é€šè¿‡å¢åŠ ä½¿æ‰€æœ‰ç»„åˆè¾¾æ ‡ï¼ˆ${optimalSolution.failedCount}ä¸ªç»„åˆå—é™ï¼‰`;
      } else {
        optimalSummary = 'éœ€è¦è¾ƒå¤§å¹…åº¦è°ƒæ•´';
      }

      summary.innerHTML = `
        <strong>ğŸ“ åˆ†ææ€»ç»“ï¼š</strong><br>
        â€¢ å…±æœ‰ <strong>${failedCombinations.length}</strong> ä¸ªå¤±è´¥ç»„åˆ<br>
        ${failurePercentage > 0 ? `â€¢ <strong>${highestFailElement.name}</strong> å¤±è´¥æ¯”ä¾‹æœ€é«˜ï¼ˆ${failurePercentage}%ï¼Œ${highestFailElement.failureCount}/${highestFailElement.totalCount}æ¬¡ï¼‰<br>` : ''}
        â€¢ æœ€ä¼˜æ–¹æ¡ˆï¼š${optimalSummary}
      `;
      analysisSection.appendChild(summary);

      analysisContainer.appendChild(analysisSection);
    }

    // ç”ŸæˆæŠ¥å‘Šé•¿å›¾åŠŸèƒ½
    function generateReportImage(element, reportType) {
      // æ£€æŸ¥html2canvasæ˜¯å¦åŠ è½½
      if (typeof html2canvas === 'undefined') {
        alert('å›¾ç‰‡ç”Ÿæˆåº“åŠ è½½å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•');
        return;
      }

      // æ˜¾ç¤ºåŠ è½½çŠ¶æ€
      const loadingOverlay = document.createElement('div');
      loadingOverlay.style.position = 'fixed';
      loadingOverlay.style.top = '0';
      loadingOverlay.style.left = '0';
      loadingOverlay.style.width = '100%';
      loadingOverlay.style.height = '100%';
      loadingOverlay.style.backgroundColor = 'rgba(0, 0, 0, 0.7)';
      loadingOverlay.style.display = 'flex';
      loadingOverlay.style.justifyContent = 'center';
      loadingOverlay.style.alignItems = 'center';
      loadingOverlay.style.zIndex = '9999';
      loadingOverlay.innerHTML = `
        <div style="background: white; padding: 30px; border-radius: 15px; text-align: center; box-shadow: 0 10px 30px rgba(0,0,0,0.3);">
          <div style="font-size: 2em; margin-bottom: 15px;">ğŸ“¸</div>
          <div style="font-size: 1.2em; color: #333; margin-bottom: 10px;">æ­£åœ¨ç”ŸæˆæŠ¥å‘Šé•¿å›¾...</div>
          <div style="font-size: 0.9em; color: #666;">è¯·ç¨å€™</div>
        </div>
      `;
      document.body.appendChild(loadingOverlay);

      // ä½¿ç”¨html2canvasç”Ÿæˆå›¾ç‰‡
      html2canvas(element, {
        scale: 2, // æé«˜æ¸…æ™°åº¦
        useCORS: true, // å…è®¸è·¨åŸŸ
        allowTaint: true,
        backgroundColor: '#ffffff',
        width: element.scrollWidth,
        height: element.scrollHeight,
        scrollX: 0,
        scrollY: 0
      }).then(canvas => {
        // æ·»åŠ æ°´å°
        addWatermarkToCanvas(canvas);

        // ä¸‹è½½å›¾ç‰‡
        downloadCanvasAsImage(canvas, reportType);

        // ç§»é™¤åŠ è½½çŠ¶æ€
        document.body.removeChild(loadingOverlay);

        // æ˜¾ç¤ºæˆåŠŸæç¤º
        showSuccessMessage('æŠ¥å‘Šé•¿å›¾å·²ç”Ÿæˆå¹¶ä¸‹è½½ï¼');
      }).catch(error => {
        console.error('ç”Ÿæˆå›¾ç‰‡å¤±è´¥:', error);
        document.body.removeChild(loadingOverlay);
        alert('ç”Ÿæˆå›¾ç‰‡å¤±è´¥ï¼Œè¯·ç¨åé‡è¯•');
      });
    }

    // åœ¨Canvasä¸Šæ·»åŠ æ°´å°
    function addWatermarkToCanvas(canvas) {
      const ctx = canvas.getContext('2d');
      ctx.save();

      // è®¾ç½®æ°´å°æ ·å¼
      ctx.globalAlpha = 0.1;
      ctx.fillStyle = '#666666';
      ctx.font = '28px Arial';
      ctx.textAlign = 'right';
      ctx.textBaseline = 'bottom';

      // ç»˜åˆ¶æ°´å°
      ctx.fillText('å…ƒç´ æ•°å€¼ç»„åˆåˆ†æå™¨', canvas.width - 40, canvas.height - 40);

      ctx.restore();
    }

    // ä¸‹è½½Canvasä¸ºå›¾ç‰‡
    function downloadCanvasAsImage(canvas, reportType) {
      // è½¬æ¢ä¸ºblob
      canvas.toBlob(function(blob) {
        // åˆ›å»ºä¸‹è½½é“¾æ¥
        const url = URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;

        // è®¾ç½®æ–‡ä»¶å
        const timestamp = new Date().toISOString().slice(0, 19).replace(/:/g, '-');
        const fileName = `å…ƒç´ åˆ†ææŠ¥å‘Š_${reportType.replace(/[()ï¼ˆï¼‰]/g, '')}_${timestamp}.png`;
        link.download = fileName;

        // è§¦å‘ä¸‹è½½
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);

        // æ¸…ç†URL
        URL.revokeObjectURL(url);
      }, 'image/png', 0.95);
    }

    // æ˜¾ç¤ºæˆåŠŸæç¤º
    function showSuccessMessage(message) {
      const toast = document.createElement('div');
      toast.style.position = 'fixed';
      toast.style.top = '20px';
      toast.style.right = '20px';
      toast.style.background = 'linear-gradient(135deg, #28a745, #20c997)';
      toast.style.color = 'white';
      toast.style.padding = '15px 20px';
      toast.style.borderRadius = '10px';
      toast.style.boxShadow = '0 5px 15px rgba(40, 167, 69, 0.3)';
      toast.style.zIndex = '10000';
      toast.style.fontSize = '14px';
      toast.style.fontWeight = '600';
      toast.textContent = message;

      document.body.appendChild(toast);

      // 3ç§’åè‡ªåŠ¨æ¶ˆå¤±
      setTimeout(() => {
        toast.style.opacity = '0';
        toast.style.transform = 'translateX(100%)';
        toast.style.transition = 'all 0.3s ease';
        setTimeout(() => {
          document.body.removeChild(toast);
        }, 300);
      }, 3000);
    }
  </script>

</body>

</html>